<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ROii2 - Initial D Mode</title>

    <script src="libs/three.min.js"></script>
    <script src="libs/OrbitControls.js"></script>
    <script src="libs/GLTFLoader.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Orbitron', -apple-system, sans-serif;
            background: #000;
            overflow: hidden;
            color: white;
        }
        #canvas3d { width: 100vw; height: 100vh; }

        .hud {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        /* Top Bar */
        .top-bar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .version-links {
            display: flex;
            gap: 8px;
            pointer-events: auto;
        }
        .version-link {
            padding: 10px 16px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #ff6b00;
            border-radius: 4px;
            font-size: 11px;
            color: #ff6b00;
            text-decoration: none;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
        }
        .version-link:hover { background: rgba(255, 107, 0, 0.3); }
        .version-link.active { background: #ff6b00; color: black; }

        .title {
            background: rgba(0,0,0,0.8);
            padding: 12px 24px;
            border: 2px solid #ff6b00;
            text-align: center;
        }
        .title h1 {
            font-size: 20px;
            color: #ff6b00;
            text-shadow: 0 0 20px rgba(255, 107, 0, 0.8);
            letter-spacing: 3px;
        }
        .title p {
            font-size: 10px;
            color: #666;
            letter-spacing: 2px;
        }

        /* Speedometer - Digital */
        .speedometer {
            position: absolute;
            bottom: 40px;
            right: 40px;
            background: rgba(0,0,0,0.9);
            padding: 30px 40px;
            border: 3px solid #ff6b00;
            text-align: center;
            clip-path: polygon(0 10%, 10% 0, 90% 0, 100% 10%, 100% 90%, 90% 100%, 10% 100%, 0 90%);
        }
        .speed-value {
            font-size: 90px;
            font-weight: 700;
            color: #ff6b00;
            line-height: 1;
            text-shadow: 0 0 30px rgba(255, 107, 0, 0.8), 0 0 60px rgba(255, 107, 0, 0.4);
            font-family: 'Orbitron', monospace;
        }
        .speed-unit {
            font-size: 18px;
            color: #666;
            margin-top: 5px;
            letter-spacing: 4px;
        }

        /* Tachometer */
        .tachometer {
            position: absolute;
            bottom: 40px;
            right: 230px;
            background: rgba(0,0,0,0.9);
            padding: 20px 30px;
            border: 2px solid #00ff88;
            text-align: center;
        }
        .rpm-value {
            font-size: 36px;
            font-weight: 700;
            color: #00ff88;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.6);
        }
        .rpm-label { font-size: 10px; color: #666; letter-spacing: 2px; }

        /* Drift Indicator */
        .drift-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: 700;
            color: #ff0066;
            text-shadow: 0 0 30px #ff0066, 0 0 60px #ff0066;
            opacity: 0;
            transition: opacity 0.2s;
            letter-spacing: 10px;
        }
        .drift-indicator.visible { opacity: 1; }

        /* Controls */
        .controls-help {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 15px 30px;
            border: 1px solid rgba(255, 107, 0, 0.4);
            display: flex;
            gap: 20px;
        }
        .key {
            display: inline-block;
            background: #1a1a1a;
            padding: 6px 12px;
            border: 1px solid #ff6b00;
            font-weight: bold;
            font-family: monospace;
            min-width: 24px;
            text-align: center;
            margin-right: 5px;
            color: #ff6b00;
        }
        .control-item { font-size: 12px; color: #888; letter-spacing: 1px; }

        /* Speed Lines Overlay */
        .speed-lines {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            opacity: 0;
            background: radial-gradient(ellipse at center, transparent 40%, rgba(255, 107, 0, 0.1) 100%);
            transition: opacity 0.3s;
        }
        .speed-lines.active { opacity: 1; }

        /* Stage Info */
        .stage-info {
            position: absolute;
            top: 100px;
            left: 30px;
            background: rgba(0,0,0,0.8);
            padding: 15px 25px;
            border-left: 4px solid #ff6b00;
        }
        .stage-name {
            font-size: 14px;
            color: #ff6b00;
            letter-spacing: 2px;
        }
        .stage-detail {
            font-size: 11px;
            color: #666;
            margin-top: 4px;
        }

        .toast {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            padding: 20px 40px;
            background: #ff6b00;
            color: black;
            font-weight: 700;
            font-size: 18px;
            letter-spacing: 3px;
            opacity: 0;
            transition: all 0.3s;
            z-index: 1000;
        }
        .toast.visible { opacity: 1; transform: translate(-50%, -50%) scale(1); }

        .btn-group {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            pointer-events: auto;
        }
        .btn {
            padding: 12px 24px;
            border: 2px solid #ff6b00;
            background: rgba(0,0,0,0.8);
            font-weight: 700;
            cursor: pointer;
            font-size: 12px;
            color: #ff6b00;
            letter-spacing: 1px;
            transition: all 0.2s;
        }
        .btn:hover { background: rgba(255, 107, 0, 0.2); }
    </style>
</head>
<body>
    <div id="canvas3d"></div>

    <div class="hud">
        <div class="top-bar">
            <div class="version-links">
                <a href="index.html" class="version-link">Network</a>
                <a href="drive.html" class="version-link">Drive</a>
                <a href="mobile.html" class="version-link">Mobile</a>
                <a href="initiald.html" class="version-link active">Initial D</a>
            </div>
            <div class="title">
                <h1>INITIAL D</h1>
                <p>TSN RACING STAGE</p>
            </div>
        </div>

        <div class="btn-group">
            <button class="btn" id="resetBtn"><i class="fas fa-redo"></i> RESET</button>
        </div>

        <div class="stage-info">
            <div class="stage-name">AKINA TOUGE</div>
            <div class="stage-detail">DOWNHILL BATTLE</div>
        </div>

        <div class="speedometer">
            <div class="speed-value" id="speedValue">0</div>
            <div class="speed-unit">KM/H</div>
        </div>

        <div class="tachometer">
            <div class="rpm-value" id="rpmValue">0</div>
            <div class="rpm-label">RPM</div>
        </div>

        <div class="drift-indicator" id="driftIndicator">DRIFT!</div>

        <div class="controls-help">
            <span class="control-item"><span class="key">W</span> ACCEL</span>
            <span class="control-item"><span class="key">S</span> BRAKE</span>
            <span class="control-item"><span class="key">A</span><span class="key">D</span> STEER</span>
            <span class="control-item"><span class="key">SPACE</span> DRIFT</span>
        </div>

        <div class="speed-lines" id="speedLines"></div>
    </div>

    <div class="toast" id="toast"></div>

    <script>
    // ROii2 - Initial D Mode

    const scene = new THREE.Scene();

    // Night sky gradient
    const canvas = document.createElement('canvas');
    canvas.width = 2;
    canvas.height = 1024;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createLinearGradient(0, 0, 0, 1024);
    gradient.addColorStop(0, '#000000');
    gradient.addColorStop(0.3, '#0a0515');
    gradient.addColorStop(0.5, '#150a20');
    gradient.addColorStop(0.7, '#1a0f25');
    gradient.addColorStop(1, '#0f0818');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 2, 1024);
    const skyTexture = new THREE.CanvasTexture(canvas);
    scene.background = skyTexture;

    scene.fog = new THREE.FogExp2(0x0a0515, 0.004);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.getElementById('canvas3d').appendChild(renderer.domElement);

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Lighting - Brighter for visible vehicle
    scene.add(new THREE.AmbientLight(0xFFFFFF, 1.0));

    const moonLight = new THREE.DirectionalLight(0xFFFFFF, 1.2);
    moonLight.position.set(50, 100, 50);
    moonLight.castShadow = true;
    scene.add(moonLight);

    // Fill light from above
    const fillLight = new THREE.DirectionalLight(0xFFFFFF, 0.8);
    fillLight.position.set(0, 50, 0);
    scene.add(fillLight);

    // Orange street lights
    for (let i = 0; i < 20; i++) {
        const light = new THREE.PointLight(0xff6b00, 0.5, 50);
        light.position.set((Math.random() - 0.5) * 200, 10, (Math.random() - 0.5) * 200);
        scene.add(light);
    }

    // Mountain road grid
    const gridMat = new THREE.LineBasicMaterial({ color: 0xff6b00, transparent: true, opacity: 0.15 });
    const gridSize = 2000;
    const gridDivisions = 80;
    const gridGeo = new THREE.BufferGeometry();
    const gridPoints = [];
    const step = gridSize / gridDivisions;
    const half = gridSize / 2;

    for (let i = 0; i <= gridDivisions; i++) {
        const pos = -half + i * step;
        gridPoints.push(-half, 0, pos, half, 0, pos);
        gridPoints.push(pos, 0, -half, pos, 0, half);
    }
    gridGeo.setAttribute('position', new THREE.Float32BufferAttribute(gridPoints, 3));
    const grid = new THREE.LineSegments(gridGeo, gridMat);
    grid.position.y = -1;
    scene.add(grid);

    // Stars
    const starCount = 500;
    const starGeo = new THREE.BufferGeometry();
    const starPositions = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount; i++) {
        starPositions[i * 3] = (Math.random() - 0.5) * 1000;
        starPositions[i * 3 + 1] = Math.random() * 200 + 50;
        starPositions[i * 3 + 2] = (Math.random() - 0.5) * 1000;
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
    const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({
        color: 0xffffff, size: 0.5, transparent: true, opacity: 0.8
    }));
    scene.add(stars);

    // State
    const state = {
        vehicleGroup: new THREE.Group(),
        devices: new Map(),
        connections: [],
        deviceCounter: 1
    };
    scene.add(state.vehicleGroup);

    const drive = {
        speed: 0,
        maxSpeed: 4.0,
        acceleration: 0.08,
        steering: 0,
        drift: 0,
        driftAmount: 0,
        isDrifting: false,
        keys: { w: false, a: false, s: false, d: false, space: false }
    };

    // Templates
    const templates = {
        lan9692: { color: 0xff6b00, size: [4, 2, 4] },
        hpc: { color: 0xff0066, size: [5, 2.5, 5] },
        camera: { color: 0x00ff88, size: [0.8, 0.8, 0.8] },
        lidar: { color: 0xff6b00, size: [1.2, 1.2, 1.2] },
        radar: { color: 0x00ccff, size: [1.2, 1.2, 1.2] }
    };

    let vehicleMeshes = [];

    function createVehicle() {
        const loader = new THREE.GLTFLoader();
        loader.load('./roii.glb',
            (gltf) => {
                const model = gltf.scene;
                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());
                const scale = 40 / Math.max(size.x, size.y, size.z);
                model.scale.set(scale, scale, scale);
                model.position.set(-center.x, -center.y + size.y * scale * 0.5 + 0.5, -center.z);

                model.traverse((child) => {
                    if (child.isMesh) {
                        child.material.transparent = true;
                        child.material.opacity = 0.85;
                        child.material.side = THREE.DoubleSide;
                        child.castShadow = true;
                        // Racing style - slightly bright with orange tint
                        if (child.material.color) {
                            child.material.color.multiplyScalar(1.8);
                        }
                        child.material.emissive = new THREE.Color(0xff6600);
                        child.material.emissiveIntensity = 0.15;
                        vehicleMeshes.push(child);
                    }
                });

                state.vehicleGroup.add(model);
            },
            null,
            () => createProceduralVehicle()
        );
    }

    function createProceduralVehicle() {
        const mat = new THREE.MeshPhysicalMaterial({
            color: 0x1a1a1a, metalness: 0.9, roughness: 0.1, clearcoat: 1.0
        });

        const chassis = new THREE.Mesh(new THREE.BoxGeometry(16, 8, 36), mat);
        chassis.position.y = 5;
        chassis.castShadow = true;
        state.vehicleGroup.add(chassis);

        // Headlights
        const headlightMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        [[-6, 3, 18], [6, 3, 18]].forEach(pos => {
            const light = new THREE.Mesh(new THREE.BoxGeometry(3, 2, 0.5), headlightMat);
            light.position.set(...pos);
            state.vehicleGroup.add(light);
        });

        // Taillights
        const tailMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        [[-6, 4, -18], [6, 4, -18]].forEach(pos => {
            const light = new THREE.Mesh(new THREE.BoxGeometry(3, 1.5, 0.5), tailMat);
            light.position.set(...pos);
            state.vehicleGroup.add(light);
        });
    }

    function addDevice(type, position, label) {
        const t = templates[type];
        const id = `dev-${state.deviceCounter++}`;
        const device = { id, type, label, position: position.clone() };

        const geo = type === 'lidar' && !label.includes('Center') ?
            new THREE.CylinderGeometry(t.size[0] * 0.5, t.size[0] * 0.5, t.size[1], 16) :
            new THREE.BoxGeometry(...t.size);

        const mat = new THREE.MeshPhongMaterial({
            color: t.color, emissive: t.color, emissiveIntensity: 0.8, shininess: 100
        });

        const group = new THREE.Group();
        const mesh = new THREE.Mesh(geo, mat);
        mesh.castShadow = true;
        group.add(mesh);
        group.add(new THREE.LineSegments(
            new THREE.EdgesGeometry(geo),
            new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.6, transparent: true })
        ));
        group.position.copy(position);
        device.mesh = group;

        state.vehicleGroup.add(group);
        state.devices.set(id, device);
        return device;
    }

    function createConnection(from, to) {
        const color = from.type === 'lan9692' && to.type === 'lan9692' ? 0xff6b00 :
                      from.type === 'hpc' || to.type === 'hpc' ? 0xff0066 : 0x00ff88;

        const curve = new THREE.CatmullRomCurve3([from.position.clone(), to.position.clone()]);
        const tube = new THREE.Mesh(
            new THREE.TubeGeometry(curve, 16, 0.08, 8, false),
            new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.7 })
        );
        state.vehicleGroup.add(tube);

        const particles = [];
        for (let i = 0; i < 4; i++) {
            const p = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            p.userData = { t: i / 4, curve };
            state.vehicleGroup.add(p);
            particles.push(p);
        }

        state.connections.push({ from, to, tube, particles });
    }

    function loadScenario() {
        createVehicle();

        const acuIT = addDevice('hpc', new THREE.Vector3(0, 4, 0), 'ACU_IT');
        const frontL = addDevice('lan9692', new THREE.Vector3(-3.5, 4, 10), 'Front-L');
        const frontR = addDevice('lan9692', new THREE.Vector3(3.5, 4, 10), 'Front-R');
        const rear = addDevice('lan9692', new THREE.Vector3(0, 4, -10), 'Rear');

        // Sensors
        const lidarFL = addDevice('lidar', new THREE.Vector3(-8.5, 10, 16.2), 'LiDAR-FL');
        const lidarFR = addDevice('lidar', new THREE.Vector3(8.5, 10, 16.2), 'LiDAR-FR');
        addDevice('lidar', new THREE.Vector3(0, 5.5, 18.5), 'LiDAR-FC');
        addDevice('lidar', new THREE.Vector3(0, 5.5, -18.5), 'LiDAR-RC');

        addDevice('camera', new THREE.Vector3(0, 10.5, 18.5), 'Cam-FC');
        addDevice('camera', new THREE.Vector3(-8.5, 11, 16.5), 'Cam-SL');
        addDevice('camera', new THREE.Vector3(8.5, 11, 16.5), 'Cam-SR');
        addDevice('camera', new THREE.Vector3(0, 9, -18.5), 'Cam-RC');

        addDevice('radar', new THREE.Vector3(0, 7, 18.5), 'Radar-FC');
        addDevice('radar', new THREE.Vector3(-7, 6.5, 17.5), 'Radar-FL');
        addDevice('radar', new THREE.Vector3(7, 6.5, 17.5), 'Radar-FR');

        createConnection(frontL, acuIT);
        createConnection(frontR, acuIT);
        createConnection(rear, acuIT);
        createConnection(frontL, frontR);

        state.devices.forEach(d => {
            if (['lidar', 'camera', 'radar'].includes(d.type)) {
                const zone = d.position.z > 0 ? (d.position.x < 0 ? frontL : frontR) : rear;
                createConnection(zone, d);
            }
        });

        showToast('STAGE START!');
    }

    // Driving
    function updateDrive() {
        // Acceleration
        if (drive.keys.w) {
            drive.speed = Math.min(drive.speed + drive.acceleration, drive.maxSpeed);
        } else if (drive.keys.s) {
            drive.speed = Math.max(drive.speed - drive.acceleration * 1.5, -drive.maxSpeed * 0.3);
        } else {
            drive.speed *= 0.98;
            if (Math.abs(drive.speed) < 0.01) drive.speed = 0;
        }

        // Drift
        drive.isDrifting = drive.keys.space && Math.abs(drive.speed) > 1.5;
        const driftIndicator = document.getElementById('driftIndicator');
        const speedLines = document.getElementById('speedLines');

        if (drive.isDrifting) {
            drive.driftAmount = Math.min(drive.driftAmount + 0.05, 1);
            driftIndicator.classList.add('visible');
        } else {
            drive.driftAmount *= 0.9;
            if (drive.driftAmount < 0.1) driftIndicator.classList.remove('visible');
        }

        // Speed lines effect
        if (Math.abs(drive.speed) > 2) {
            speedLines.classList.add('active');
        } else {
            speedLines.classList.remove('active');
        }

        // Steering
        const steerMultiplier = drive.isDrifting ? 1.8 : 1;
        if (Math.abs(drive.speed) > 0.05) {
            if (drive.keys.a) {
                drive.steering = Math.min(drive.steering + 0.003 * steerMultiplier, 0.05);
            } else if (drive.keys.d) {
                drive.steering = Math.max(drive.steering - 0.003 * steerMultiplier, -0.05);
            } else {
                drive.steering *= 0.85;
            }
        }

        // Apply movement
        state.vehicleGroup.translateZ(drive.speed);
        state.vehicleGroup.rotateY(drive.steering * (drive.speed > 0 ? 1 : -1));

        // Drift rotation
        if (drive.isDrifting) {
            state.vehicleGroup.rotateY(drive.driftAmount * (drive.keys.a ? 0.02 : drive.keys.d ? -0.02 : 0));
        }

        // Update UI
        document.getElementById('speedValue').textContent = Math.abs(drive.speed * 60).toFixed(0);
        document.getElementById('rpmValue').textContent = (Math.abs(drive.speed) * 2000 + 800).toFixed(0);
    }

    function updateCamera() {
        const offset = new THREE.Vector3(0, 20, -55);
        const cameraTarget = offset.clone().applyMatrix4(state.vehicleGroup.matrixWorld);
        camera.position.lerp(cameraTarget, 0.06);

        const lookTarget = new THREE.Vector3(0, 5, 30);
        lookTarget.applyMatrix4(state.vehicleGroup.matrixWorld);
        camera.lookAt(lookTarget);
    }

    // Input
    window.addEventListener('keydown', (e) => {
        switch (e.key.toLowerCase()) {
            case 'w': drive.keys.w = true; break;
            case 'a': drive.keys.a = true; break;
            case 's': drive.keys.s = true; break;
            case 'd': drive.keys.d = true; break;
            case ' ': drive.keys.space = true; e.preventDefault(); break;
        }
    });

    window.addEventListener('keyup', (e) => {
        switch (e.key.toLowerCase()) {
            case 'w': drive.keys.w = false; break;
            case 'a': drive.keys.a = false; break;
            case 's': drive.keys.s = false; break;
            case 'd': drive.keys.d = false; break;
            case ' ': drive.keys.space = false; break;
        }
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
        state.vehicleGroup.position.set(0, 0, 0);
        state.vehicleGroup.rotation.set(0, 0, 0);
        drive.speed = 0;
        drive.steering = 0;
        drive.driftAmount = 0;
        showToast('RESTART');
    });

    function showToast(msg) {
        const toast = document.getElementById('toast');
        toast.textContent = msg;
        toast.classList.add('visible');
        setTimeout(() => toast.classList.remove('visible'), 2000);
    }

    function animate() {
        requestAnimationFrame(animate);

        updateDrive();
        updateCamera();

        // Infinite grid
        const pos = state.vehicleGroup.position;
        const gridStep = gridSize / gridDivisions;
        grid.position.x = Math.floor(pos.x / gridStep) * gridStep;
        grid.position.z = Math.floor(pos.z / gridStep) * gridStep;

        // Star rotation
        stars.rotation.y += 0.0001;

        // Animate particles
        state.connections.forEach(conn => {
            conn.particles.forEach(p => {
                p.userData.t += 0.015;
                if (p.userData.t > 1) p.userData.t = 0;
                p.position.copy(p.userData.curve.getPoint(p.userData.t));
            });
        });

        renderer.render(scene, camera);
    }

    loadScenario();
    animate();
    </script>
</body>
</html>
