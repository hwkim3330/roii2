<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ROii2 - TRON Wireframe</title>
    <script src="libs/three.min.js"></script>
    <script src="libs/OrbitControls.js"></script>
    <script src="libs/GLTFLoader.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Orbitron', sans-serif;
            background: #000;
            overflow: hidden;
            color: #00ffff;
        }
        #canvas3d { width: 100vw; height: 100vh; }

        /* Scanline effect */
        .scanlines {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            z-index: 100;
        }

        .vignette {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(0,0,0,0.7) 100%);
            z-index: 99;
        }

        .title {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 101;
        }
        .title h1 {
            font-size: 48px;
            font-weight: 700;
            letter-spacing: 15px;
            text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff, 0 0 60px #00ffff;
            animation: glow 2s ease-in-out infinite alternate;
        }
        @keyframes glow {
            from { text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff; }
            to { text-shadow: 0 0 30px #00ffff, 0 0 60px #00ffff, 0 0 80px #00ffff; }
        }
        .title p {
            font-size: 12px;
            letter-spacing: 8px;
            margin-top: 10px;
            color: #00aaaa;
        }

        .stats-panel {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 40px;
            z-index: 101;
        }
        .stat {
            text-align: center;
            padding: 15px 30px;
            border: 1px solid #00ffff;
            background: rgba(0, 255, 255, 0.05);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3), inset 0 0 20px rgba(0, 255, 255, 0.1);
        }
        .stat-value {
            font-size: 36px;
            font-weight: 700;
            text-shadow: 0 0 10px #00ffff;
        }
        .stat-label {
            font-size: 10px;
            letter-spacing: 3px;
            margin-top: 5px;
            color: #00aaaa;
        }

        .corner-frame {
            position: absolute;
            width: 50px;
            height: 50px;
            border: 2px solid #00ffff;
            z-index: 101;
        }
        .corner-frame.tl { top: 20px; left: 20px; border-right: none; border-bottom: none; }
        .corner-frame.tr { top: 20px; right: 20px; border-left: none; border-bottom: none; }
        .corner-frame.bl { bottom: 20px; left: 20px; border-right: none; border-top: none; }
        .corner-frame.br { bottom: 20px; right: 20px; border-left: none; border-top: none; }

        .info-panel {
            position: absolute;
            top: 100px;
            left: 30px;
            font-size: 11px;
            letter-spacing: 2px;
            z-index: 101;
        }
        .info-row {
            padding: 8px 0;
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
            display: flex;
            gap: 20px;
        }
        .info-row span:first-child { color: #00aaaa; }
        .info-row span:last-child { color: #00ffff; text-shadow: 0 0 5px #00ffff; }

        .nav-panel {
            position: absolute;
            top: 100px;
            right: 30px;
            z-index: 101;
        }
        .nav-btn {
            display: block;
            padding: 12px 25px;
            margin-bottom: 10px;
            border: 1px solid #00ffff;
            background: transparent;
            color: #00ffff;
            text-decoration: none;
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            letter-spacing: 3px;
            transition: all 0.3s;
            text-align: center;
        }
        .nav-btn:hover, .nav-btn.active {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 30px #00ffff;
        }
    </style>
</head>
<body>
    <div id="canvas3d"></div>
    <div class="scanlines"></div>
    <div class="vignette"></div>

    <div class="corner-frame tl"></div>
    <div class="corner-frame tr"></div>
    <div class="corner-frame bl"></div>
    <div class="corner-frame br"></div>

    <div class="title">
        <h1>ROii2</h1>
        <p>AUTONOMOUS NETWORK GRID</p>
    </div>

    <div class="info-panel">
        <div class="info-row"><span>SYSTEM</span><span>ONLINE</span></div>
        <div class="info-row"><span>NODES</span><span id="nodeCount">0</span></div>
        <div class="info-row"><span>LINKS</span><span id="linkCount">0</span></div>
        <div class="info-row"><span>BANDWIDTH</span><span id="bandwidth">0 GBPS</span></div>
        <div class="info-row"><span>LATENCY</span><span>&lt;2 Î¼s</span></div>
        <div class="info-row"><span>STATUS</span><span>NOMINAL</span></div>
    </div>

    <div class="nav-panel">
        <a href="index.html" class="nav-btn">NETWORK</a>
        <a href="drive.html" class="nav-btn">DRIVE</a>
        <a href="wireframe.html" class="nav-btn active">TRON</a>
        <a href="hologram.html" class="nav-btn">HOLO</a>
        <a href="blueprint.html" class="nav-btn">BLUEPRINT</a>
    </div>

    <div class="stats-panel">
        <div class="stat">
            <div class="stat-value">4</div>
            <div class="stat-label">LIDAR</div>
        </div>
        <div class="stat">
            <div class="stat-value">8</div>
            <div class="stat-label">CAMERA</div>
        </div>
        <div class="stat">
            <div class="stat-value">5</div>
            <div class="stat-label">RADAR</div>
        </div>
        <div class="stat">
            <div class="stat-value">3</div>
            <div class="stat-label">ZONES</div>
        </div>
    </div>

    <script>
    // === THREE.JS SETUP ===
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.FogExp2(0x000000, 0.008);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(50, 40, 50);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('canvas3d').appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.8;

    // === TRON GRID ===
    const gridSize = 200;
    const gridDivisions = 40;
    const gridMat = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3 });
    const gridGeo = new THREE.BufferGeometry();
    const gridPoints = [];
    const step = gridSize / gridDivisions;
    const half = gridSize / 2;

    for (let i = 0; i <= gridDivisions; i++) {
        const pos = -half + i * step;
        gridPoints.push(-half, 0, pos, half, 0, pos);
        gridPoints.push(pos, 0, -half, pos, 0, half);
    }
    gridGeo.setAttribute('position', new THREE.Float32BufferAttribute(gridPoints, 3));
    const grid = new THREE.LineSegments(gridGeo, gridMat);
    scene.add(grid);

    // Glow effect for grid center
    const glowGeo = new THREE.RingGeometry(5, 50, 64);
    const glowMat = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.1,
        side: THREE.DoubleSide
    });
    const glow = new THREE.Mesh(glowGeo, glowMat);
    glow.rotation.x = -Math.PI / 2;
    glow.position.y = 0.1;
    scene.add(glow);

    // === STATE ===
    const vehicleGroup = new THREE.Group();
    scene.add(vehicleGroup);

    const devices = new Map();
    const connections = [];
    let deviceCounter = 1;

    const templates = {
        lan9692: { color: 0x00ffff, size: [4, 2, 4] },
        hpc: { color: 0xff00ff, size: [5, 2.5, 5] },
        camera: { color: 0xffff00, size: [0.8, 0.8, 0.8] },
        lidar: { color: 0x00ff00, size: [1.2, 1.2, 1.2] },
        radar: { color: 0xff8800, size: [1.2, 1.2, 1.2] }
    };

    // === VEHICLE (Wireframe) ===
    function createVehicle() {
        const loader = new THREE.GLTFLoader();
        loader.load('./roii.glb', (gltf) => {
            const model = gltf.scene;
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            const scale = 40 / Math.max(size.x, size.y, size.z);
            model.scale.set(scale, scale, scale);
            model.position.set(-center.x, -center.y + size.y * scale * 0.5, -center.z);

            model.traverse((child) => {
                if (child.isMesh) {
                    // Neon wireframe
                    child.material = new THREE.MeshBasicMaterial({
                        color: 0x00ffff,
                        wireframe: true,
                        transparent: true,
                        opacity: 0.6
                    });
                }
            });
            vehicleGroup.add(model);
        });
    }

    // === DEVICE ===
    function addDevice(type, position, label) {
        const t = templates[type];
        const id = `device-${deviceCounter++}`;
        const group = new THREE.Group();

        // Glowing wireframe box
        const geo = new THREE.BoxGeometry(...t.size);
        const edges = new THREE.EdgesGeometry(geo);
        const lineMat = new THREE.LineBasicMaterial({ color: t.color, linewidth: 2 });
        const wireframe = new THREE.LineSegments(edges, lineMat);
        group.add(wireframe);

        // Inner glow
        const innerMat = new THREE.MeshBasicMaterial({
            color: t.color,
            transparent: true,
            opacity: 0.15
        });
        const innerMesh = new THREE.Mesh(geo, innerMat);
        group.add(innerMesh);

        // Pulsing point light
        const light = new THREE.PointLight(t.color, 0.5, 10);
        group.add(light);

        group.position.copy(position);
        vehicleGroup.add(group);

        const device = { id, type, label, position: position.clone(), mesh: group, light };
        devices.set(id, device);
        return device;
    }

    function createConnection(from, to) {
        const isBackbone = (from.type === 'lan9692' && to.type === 'lan9692') || from.type === 'hpc' || to.type === 'hpc';
        const color = isBackbone ? 0xff00ff : 0x00ffff;

        const points = [from.position.clone(), to.position.clone()];
        const geo = new THREE.BufferGeometry().setFromPoints(points);
        const mat = new THREE.LineBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.8
        });
        const line = new THREE.Line(geo, mat);
        vehicleGroup.add(line);

        // Animated particle
        const particleGeo = new THREE.SphereGeometry(0.3, 8, 8);
        const particleMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const particle = new THREE.Mesh(particleGeo, particleMat);
        vehicleGroup.add(particle);

        connections.push({
            from, to, line, particle,
            t: Math.random(),
            bandwidth: isBackbone ? '10G' : '1G'
        });
    }

    // === LOAD SCENARIO ===
    function loadScenario() {
        createVehicle();

        const acuIT = addDevice('hpc', new THREE.Vector3(0, 4, 0), 'ACU_IT');
        const frontL = addDevice('lan9692', new THREE.Vector3(-3.5, 4, 10), 'FRONT-L');
        const frontR = addDevice('lan9692', new THREE.Vector3(3.5, 4, 10), 'FRONT-R');
        const rear = addDevice('lan9692', new THREE.Vector3(0, 4, -10), 'REAR');

        // Sensors
        [[-8.5, 10, 16.2], [8.5, 10, 16.2], [0, 5.5, 18.5], [0, 5.5, -18.5]].forEach(p =>
            addDevice('lidar', new THREE.Vector3(...p), 'LIDAR'));

        [[0, 10.5, 18.5], [0.6, 10.5, 18.5], [-0.6, 10.5, 18.5], [-8.5, 11, 16.5], [8.5, 11, 16.5], [-8.5, 11, 15.9], [8.5, 11, 15.9], [0, 9, -18.5]].forEach(p =>
            addDevice('camera', new THREE.Vector3(...p), 'CAM'));

        [[0, 7, 18.5], [-7, 6.5, 17.5], [7, 6.5, 17.5], [-7, 6.5, -18], [7, 6.5, -18]].forEach(p =>
            addDevice('radar', new THREE.Vector3(...p), 'RADAR'));

        // Connections
        createConnection(frontL, acuIT);
        createConnection(frontR, acuIT);
        createConnection(rear, acuIT);
        createConnection(frontL, frontR);

        devices.forEach(d => {
            if (['lidar', 'camera', 'radar'].includes(d.type)) {
                const zone = d.position.z > 0 ? (d.position.x < 0 ? frontL : frontR) : rear;
                createConnection(zone, d);
            }
        });

        updateStats();
    }

    function updateStats() {
        document.getElementById('nodeCount').textContent = devices.size;
        document.getElementById('linkCount').textContent = connections.length;
        let bw = 0;
        connections.forEach(c => bw += c.bandwidth === '10G' ? 10 : 1);
        document.getElementById('bandwidth').textContent = bw + ' GBPS';
    }

    // === ANIMATION ===
    let time = 0;
    function animate() {
        requestAnimationFrame(animate);
        time += 0.016;

        controls.update();

        // Animate connection particles
        connections.forEach(conn => {
            conn.t += 0.015;
            if (conn.t > 1) conn.t = 0;
            const pos = conn.from.position.clone().lerp(conn.to.position, conn.t);
            conn.particle.position.copy(pos);
        });

        // Pulse device lights
        devices.forEach(d => {
            if (d.light) {
                d.light.intensity = 0.3 + Math.sin(time * 3 + d.position.x) * 0.2;
            }
        });

        // Grid glow pulse
        glow.material.opacity = 0.05 + Math.sin(time) * 0.03;

        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    loadScenario();
    animate();
    </script>
</body>
</html>
