<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ROii2 - TSN Fault Simulator</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #f8f9fa;
            --card: #ffffff;
            --border: #e9ecef;
            --text: #212529;
            --text-muted: #6c757d;
            --blue: #0d6efd;
            --green: #198754;
            --red: #dc3545;
            --yellow: #ffc107;
            --cyan: #0dcaf0;
            --purple: #6f42c1;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
            height: 100vh;
        }

        .container {
            display: grid;
            grid-template-columns: 320px 1fr 380px;
            grid-template-rows: 60px 1fr;
            height: 100vh;
        }

        /* Header */
        .header {
            grid-column: 1 / -1;
            background: var(--card);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .logo img { height: 28px; }

        .logo-divider {
            width: 1px;
            height: 20px;
            background: var(--border);
        }

        .logo h1 {
            font-size: 18px;
            font-weight: 600;
            color: var(--text);
        }

        .logo span {
            font-size: 13px;
            color: var(--text-muted);
            margin-left: 8px;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .status-pill {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
        }

        .status-pill.normal {
            background: rgba(25, 135, 84, 0.1);
            color: var(--green);
        }

        .status-pill.critical {
            background: rgba(220, 53, 69, 0.1);
            color: var(--red);
            animation: pulse-critical 1s infinite;
        }

        .status-pill.recovering {
            background: rgba(255, 193, 7, 0.15);
            color: #997404;
        }

        @keyframes pulse-critical {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
        }

        .clock {
            font-size: 13px;
            color: var(--text-muted);
            font-variant-numeric: tabular-nums;
        }

        /* Sidebar */
        .sidebar {
            background: var(--card);
            border-right: 1px solid var(--border);
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            overflow-y: auto;
        }

        .panel {
            background: var(--bg);
            border-radius: 12px;
            padding: 16px;
        }

        .panel-title {
            font-size: 11px;
            font-weight: 700;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .panel-title i {
            font-size: 12px;
        }

        /* Fault Buttons */
        .fault-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .fault-btn {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.15s;
            font-size: 13px;
            color: var(--text);
        }

        .fault-btn:hover {
            border-color: var(--red);
            background: rgba(220, 53, 69, 0.03);
        }

        .fault-btn.active {
            background: var(--red);
            border-color: var(--red);
            color: white;
        }

        .fault-btn i {
            width: 16px;
            color: var(--red);
            font-size: 12px;
        }

        .fault-btn.active i { color: white; }

        /* Recovery */
        .recovery-btn {
            width: 100%;
            padding: 14px;
            background: var(--blue);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.15s;
        }

        .recovery-btn:hover:not(:disabled) {
            background: #0b5ed7;
        }

        .recovery-btn:disabled {
            background: var(--border);
            color: var(--text-muted);
            cursor: not-allowed;
        }

        .recovery-btn.processing {
            background: var(--yellow);
            color: #000;
        }

        .recovery-btn.processing i {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Metrics */
        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .metric {
            background: var(--card);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .metric-label {
            font-size: 10px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.3px;
            margin-bottom: 4px;
        }

        .metric-value {
            font-size: 18px;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
            transition: color 0.3s;
        }

        .metric-value.good { color: var(--green); }
        .metric-value.warn { color: var(--yellow); }
        .metric-value.bad { color: var(--red); }

        .metric-unit {
            font-size: 11px;
            font-weight: 400;
            color: var(--text-muted);
        }

        /* Opacity Slider */
        .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider-group label {
            font-size: 12px;
            color: var(--text-muted);
            min-width: 60px;
        }

        .slider-group input[type="range"] {
            flex: 1;
            height: 4px;
            -webkit-appearance: none;
            background: var(--border);
            border-radius: 2px;
            outline: none;
        }

        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--blue);
            border-radius: 50%;
            cursor: pointer;
        }

        .slider-value {
            font-size: 12px;
            font-weight: 600;
            min-width: 35px;
            text-align: right;
        }

        /* Main View */
        .main-view {
            background: linear-gradient(180deg, #f0f0f0 0%, #e8e8e8 100%);
            position: relative;
        }

        #canvas3d {
            width: 100%;
            height: 100%;
        }

        .overlay-chips {
            position: absolute;
            top: 16px;
            left: 16px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: rgba(255,255,255,0.95);
            border-radius: 16px;
            font-size: 11px;
            font-weight: 500;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .chip i { color: var(--blue); font-size: 10px; }

        /* Topology */
        .topology-box {
            position: absolute;
            bottom: 16px;
            left: 16px;
            width: 280px;
            background: rgba(255,255,255,0.98);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .topology-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-muted);
            margin-bottom: 12px;
        }

        .topo-svg {
            width: 100%;
            height: 100px;
        }

        .topo-link {
            stroke: var(--cyan);
            stroke-width: 2;
            opacity: 0.5;
            transition: all 0.3s;
        }

        .topo-link.fault {
            stroke: var(--red);
            stroke-dasharray: 5 3;
            opacity: 1;
            animation: link-blink 0.4s infinite;
        }

        @keyframes link-blink {
            50% { opacity: 0.3; }
        }

        .topo-node circle {
            fill: white;
            stroke: var(--border);
            stroke-width: 2;
            transition: all 0.3s;
        }

        .topo-node.fault circle {
            stroke: var(--red);
            stroke-width: 3;
        }

        .topo-node text {
            font-size: 8px;
            font-weight: 600;
            fill: var(--text);
            text-anchor: middle;
        }

        .topo-sensor {
            transition: fill 0.3s;
        }

        .topo-sensor.fault {
            fill: var(--red) !important;
        }

        /* Right Panel */
        .right-panel {
            background: var(--card);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
        }

        /* Chart */
        .chart-box {
            padding: 16px;
            border-bottom: 1px solid var(--border);
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 12px;
        }

        .chart-label {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-muted);
        }

        .chart-big {
            font-size: 24px;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
        }

        .chart-area {
            height: 100px;
            background: var(--bg);
            border-radius: 8px;
            padding: 8px;
        }

        #ptpChart {
            width: 100%;
            height: 100%;
        }

        /* Terminal */
        .terminal-box {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .terminal-head {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .terminal-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-muted);
        }

        .live-badge {
            font-size: 9px;
            font-weight: 700;
            padding: 2px 6px;
            background: rgba(25, 135, 84, 0.1);
            color: var(--green);
            border-radius: 3px;
        }

        .terminal-logs {
            flex: 1;
            padding: 12px 16px;
            overflow-y: auto;
            background: #fafbfc;
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 11px;
            line-height: 1.7;
        }

        .log {
            display: flex;
            gap: 10px;
        }

        .log-time {
            color: #999;
            min-width: 65px;
        }

        .log-msg { color: #333; }
        .log-msg.info { color: var(--blue); }
        .log-msg.ok { color: var(--green); }
        .log-msg.err { color: var(--red); font-weight: 600; }
        .log-msg.warn { color: #b45309; }
        .log-msg.cmd { color: var(--purple); }
        .log-msg.cmd::before { content: '$ '; color: #999; }

        .terminal-prompt {
            padding: 10px 16px;
            border-top: 1px solid var(--border);
            background: #fafbfc;
            font-family: 'SF Mono', monospace;
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .prompt-user { color: var(--green); font-weight: 600; }
        .cursor {
            width: 7px;
            height: 13px;
            background: var(--blue);
            animation: blink 1s step-end infinite;
        }
        @keyframes blink { 50% { opacity: 0; } }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 5px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #ccc; border-radius: 3px; }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <div class="logo">
                <img src="keti.png" alt="KETI">
                <div class="logo-divider"></div>
                <h1>ROii2</h1>
                <span>TSN Fault Simulator</span>
            </div>
            <div class="header-right">
                <div class="status-pill normal" id="statusPill">
                    <div class="status-dot"></div>
                    <span id="statusText">Operational</span>
                </div>
                <div class="clock" id="clock">00:00:00</div>
            </div>
        </header>

        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="panel">
                <div class="panel-title"><i class="fas fa-bolt"></i> Fault Injection</div>
                <div class="fault-list">
                    <button class="fault-btn" data-fault="lidar" onclick="injectFault('lidar')">
                        <i class="fas fa-satellite-dish"></i>
                        LiDAR-FL Sensor Failure
                    </button>
                    <button class="fault-btn" data-fault="camera" onclick="injectFault('camera')">
                        <i class="fas fa-video"></i>
                        Camera Link Down
                    </button>
                    <button class="fault-btn" data-fault="backbone" onclick="injectFault('backbone')">
                        <i class="fas fa-network-wired"></i>
                        10G Backbone Fault
                    </button>
                    <button class="fault-btn" data-fault="ptp" onclick="injectFault('ptp')">
                        <i class="fas fa-clock"></i>
                        PTP Synchronization Loss
                    </button>
                    <button class="fault-btn" data-fault="zone" onclick="injectFault('zone')">
                        <i class="fas fa-microchip"></i>
                        Zone Controller Failure
                    </button>
                </div>
            </div>

            <div class="panel">
                <div class="panel-title"><i class="fas fa-tools"></i> Recovery</div>
                <button class="recovery-btn" id="recoveryBtn" onclick="startRecovery()" disabled>
                    <i class="fas fa-sync-alt"></i>
                    Auto-Reconfigure
                </button>
            </div>

            <div class="panel">
                <div class="panel-title"><i class="fas fa-tachometer-alt"></i> Network Metrics</div>
                <div class="metrics-grid">
                    <div class="metric">
                        <div class="metric-label">PTP Offset</div>
                        <div class="metric-value good" id="mPtp">48<span class="metric-unit">ns</span></div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Jitter</div>
                        <div class="metric-value good" id="mJitter">12<span class="metric-unit">ns</span></div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Packet Loss</div>
                        <div class="metric-value good" id="mLoss">0.000<span class="metric-unit">%</span></div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">CRC Errors</div>
                        <div class="metric-value good" id="mCrc">0<span class="metric-unit">/s</span></div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <div class="panel-title"><i class="fas fa-sliders-h"></i> Display</div>
                <div class="slider-group">
                    <label>Opacity</label>
                    <input type="range" min="20" max="100" value="75" id="opacitySlider" oninput="setOpacity(this.value)">
                    <span class="slider-value" id="opacityValue">75%</span>
                </div>
            </div>

            <div class="panel" style="margin-top:auto;">
                <div class="panel-title"><i class="fas fa-server"></i> Device</div>
                <div style="display:flex;align-items:center;gap:10px;font-size:13px;">
                    <span style="font-weight:600;">LAN9692</span>
                    <span style="color:var(--text-muted);">VelocityDRIVE-SP</span>
                    <span style="margin-left:auto;width:8px;height:8px;background:var(--green);border-radius:50%;"></span>
                </div>
            </div>
        </aside>

        <!-- Main 3D View -->
        <main class="main-view">
            <canvas id="canvas3d"></canvas>

            <div class="overlay-chips">
                <div class="chip"><i class="fas fa-car"></i> ROii2 Vehicle</div>
                <div class="chip"><i class="fas fa-sitemap"></i> 17 Sensors / 3 Zones</div>
            </div>

            <div class="topology-box">
                <div class="topology-title">Network Topology</div>
                <svg class="topo-svg" viewBox="0 0 240 100">
                    <line class="topo-link" id="link-hpc-fl" x1="120" y1="15" x2="40" y2="55"/>
                    <line class="topo-link" id="link-hpc-fr" x1="120" y1="15" x2="200" y2="55"/>
                    <line class="topo-link" id="link-hpc-rear" x1="120" y1="15" x2="120" y2="85"/>
                    <line class="topo-link" id="link-fl-fr" x1="40" y1="55" x2="200" y2="55"/>

                    <g class="topo-node" id="node-hpc">
                        <circle cx="120" cy="15" r="12"/>
                        <text x="120" y="18">HPC</text>
                    </g>
                    <g class="topo-node" id="node-fl">
                        <circle cx="40" cy="55" r="11"/>
                        <text x="40" y="58">FL</text>
                    </g>
                    <g class="topo-node" id="node-fr">
                        <circle cx="200" cy="55" r="11"/>
                        <text x="200" y="58">FR</text>
                    </g>
                    <g class="topo-node" id="node-rear">
                        <circle cx="120" cy="85" r="11"/>
                        <text x="120" y="88">REAR</text>
                    </g>

                    <circle class="topo-sensor" id="ts-lidar" cx="20" cy="40" r="4" fill="#198754"/>
                    <circle class="topo-sensor" id="ts-cam" cx="30" cy="35" r="3" fill="#0dcaf0"/>
                    <circle class="topo-sensor" id="ts-radar" cx="25" cy="48" r="3" fill="#ffc107"/>
                </svg>
            </div>
        </main>

        <!-- Right Panel -->
        <aside class="right-panel">
            <div class="chart-box">
                <div class="chart-header">
                    <span class="chart-label">PTP Clock Offset</span>
                    <span class="chart-big" id="chartVal">48 ns</span>
                </div>
                <div class="chart-area">
                    <canvas id="ptpChart"></canvas>
                </div>
            </div>

            <div class="terminal-box">
                <div class="terminal-head">
                    <span class="terminal-title"><i class="fas fa-terminal" style="margin-right:6px;"></i>System Log</span>
                    <span class="live-badge">LIVE</span>
                </div>
                <div class="terminal-logs" id="logs"></div>
                <div class="terminal-prompt">
                    <span class="prompt-user">root@lan9692:~#</span>
                    <div class="cursor"></div>
                </div>
            </div>
        </aside>
    </div>

    <script src="libs/three.min.js"></script>
    <script src="libs/OrbitControls.js"></script>
    <script src="libs/GLTFLoader.js"></script>
    <script>
        // ============================================
        // State & Realistic Metrics
        // ============================================
        const state = {
            status: 'normal', // normal, critical, recovering
            faults: new Set(),
            metrics: {
                ptpOffset: 48,      // nanoseconds (normal: 20-100ns)
                jitter: 12,         // nanoseconds (normal: 5-30ns)
                packetLoss: 0,      // percentage (normal: 0%)
                crcErrors: 0        // per second (normal: 0)
            },
            targetMetrics: null
        };

        let vehicleOpacity = 0.75;
        const vehicleMeshes = [];

        // ============================================
        // Three.js Setup
        // ============================================
        const canvas = document.getElementById('canvas3d');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);

        const camera = new THREE.PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
        camera.position.set(45, 30, 45);

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 25;
        controls.maxDistance = 100;
        controls.target.set(0, 5, 0);

        // Lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));

        const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
        sunLight.position.set(30, 50, 30);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);

        scene.add(new THREE.DirectionalLight(0x88aaff, 0.3).position.set(-20, 30, -20));

        // Ground
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(200, 200),
            new THREE.MeshStandardMaterial({ color: 0xe5e5e5, roughness: 0.9 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        const grid = new THREE.GridHelper(100, 50, 0xcccccc, 0xdddddd);
        grid.position.y = 0.01;
        scene.add(grid);

        // ============================================
        // Sensor Configuration (from script.js)
        // ============================================
        const sensorConfig = {
            'LiDAR-FL': { pos: [-8.5, 10, 16.2], type: 'lidar', color: 0x198754 },
            'LiDAR-FR': { pos: [8.5, 10, 16.2], type: 'lidar', color: 0x198754 },
            'LiDAR-FC': { pos: [0, 5.5, 18.5], type: 'lidar', color: 0x198754 },
            'LiDAR-RC': { pos: [0, 5.5, -18.5], type: 'lidar', color: 0x198754 },
            'Cam-FC': { pos: [0, 10.5, 18.5], type: 'camera', color: 0x0dcaf0 },
            'Cam-FL': { pos: [0.6, 10.5, 18.5], type: 'camera', color: 0x0dcaf0 },
            'Cam-FR': { pos: [-0.6, 10.5, 18.5], type: 'camera', color: 0x0dcaf0 },
            'Cam-SL1': { pos: [-8.5, 11, 16.5], type: 'camera', color: 0x0dcaf0 },
            'Cam-SR1': { pos: [8.5, 11, 16.5], type: 'camera', color: 0x0dcaf0 },
            'Cam-SL2': { pos: [-8.5, 11, 15.9], type: 'camera', color: 0x0dcaf0 },
            'Cam-SR2': { pos: [8.5, 11, 15.9], type: 'camera', color: 0x0dcaf0 },
            'Cam-RC': { pos: [0, 9, -18.5], type: 'camera', color: 0x0dcaf0 },
            'Radar-FC': { pos: [0, 7, 18.5], type: 'radar', color: 0xffc107 },
            'Radar-FL': { pos: [-7, 6.5, 17.5], type: 'radar', color: 0xffc107 },
            'Radar-FR': { pos: [7, 6.5, 17.5], type: 'radar', color: 0xffc107 },
            'Radar-RL': { pos: [-7, 6.5, -18], type: 'radar', color: 0xffc107 },
            'Radar-RR': { pos: [7, 6.5, -18], type: 'radar', color: 0xffc107 }
        };

        const sensors = {};
        const sensorMeshes = [];

        // ============================================
        // Zone Controllers (HPC + 3x LAN9692)
        // ============================================
        const zoneConfig = {
            'ACU_IT': { pos: [0, 4, 0], type: 'hpc', color: 0xffd700, size: [3, 1.5, 2] },
            'Front-L-9692': { pos: [-3.5, 4, 10], type: 'lan9692', color: 0x3b82f6, size: [2, 1, 1.5] },
            'Front-R-9692': { pos: [3.5, 4, 10], type: 'lan9692', color: 0x3b82f6, size: [2, 1, 1.5] },
            'Rear-9692': { pos: [0, 4, -10], type: 'lan9692', color: 0x3b82f6, size: [2, 1, 1.5] }
        };

        const zoneControllers = {};
        const networkLines = [];

        // Sensor to Zone mapping
        const sensorZoneMap = {
            'LiDAR-FL': 'Front-L-9692', 'LiDAR-FC': 'Front-L-9692',
            'Cam-FL': 'Front-L-9692', 'Cam-SL1': 'Front-L-9692', 'Cam-SL2': 'Front-L-9692',
            'Radar-FL': 'Front-L-9692',
            'LiDAR-FR': 'Front-R-9692',
            'Cam-FC': 'Front-R-9692', 'Cam-FR': 'Front-R-9692', 'Cam-SR1': 'Front-R-9692', 'Cam-SR2': 'Front-R-9692',
            'Radar-FC': 'Front-R-9692', 'Radar-FR': 'Front-R-9692',
            'LiDAR-RC': 'Rear-9692', 'Cam-RC': 'Rear-9692',
            'Radar-RL': 'Rear-9692', 'Radar-RR': 'Rear-9692'
        };

        // ============================================
        // Load Vehicle (Keep Original Textures!)
        // ============================================
        const loader = new THREE.GLTFLoader();
        loader.load('roii.glb', (gltf) => {
            const model = gltf.scene;
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());

            const targetSize = 40;
            const scale = targetSize / Math.max(size.x, size.y, size.z);
            model.scale.set(scale, scale, scale);

            const scaledHeight = size.y * scale;
            model.position.set(-center.x * scale, -center.y * scale + scaledHeight * 0.5 + 0.5, -center.z * scale);

            // Keep original materials, just modify them
            model.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.material.transparent = true;
                    child.material.opacity = vehicleOpacity;
                    child.material.side = THREE.DoubleSide;
                    if (child.material.color) {
                        child.material.color.multiplyScalar(1.5);
                    }
                    child.material.emissive = new THREE.Color(0x333333);
                    child.material.emissiveIntensity = 0.2;
                    child.castShadow = true;
                    child.receiveShadow = true;
                    vehicleMeshes.push(child);
                }
            });

            scene.add(model);
            createSensors();
            createZoneControllers();
            createNetworkConnections();

            log('info', 'ROii2 vehicle model loaded successfully');
            log('ok', 'LAN9692 VelocityDRIVE-SP x3 connected');
            log('info', 'ACU_IT (HPC) initialized - TSN gateway active');
            log('info', 'PTP grandmaster synchronized (GM: 00:1B:19:00:00:00)');
            log('ok', 'All 17 sensors online, network topology established');
        });

        function createSensors() {
            Object.entries(sensorConfig).forEach(([name, cfg]) => {
                let geo;
                if (cfg.type === 'lidar') geo = new THREE.OctahedronGeometry(0.6);
                else if (cfg.type === 'camera') geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                else geo = new THREE.ConeGeometry(0.4, 0.8, 8);

                const mat = new THREE.MeshStandardMaterial({
                    color: cfg.color,
                    emissive: cfg.color,
                    emissiveIntensity: 0.3,
                    metalness: 0.5,
                    roughness: 0.3
                });

                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(...cfg.pos);
                mesh.name = name;
                mesh.userData = { type: cfg.type, baseColor: cfg.color, fault: false };

                scene.add(mesh);
                sensors[name] = mesh;
                sensorMeshes.push(mesh);
            });
        }

        // ============================================
        // Create Zone Controllers
        // ============================================
        function createZoneControllers() {
            Object.entries(zoneConfig).forEach(([name, cfg]) => {
                const group = new THREE.Group();

                // Main box
                const geo = new THREE.BoxGeometry(...cfg.size);
                const mat = new THREE.MeshStandardMaterial({
                    color: cfg.color,
                    metalness: 0.7,
                    roughness: 0.3,
                    transparent: true,
                    opacity: 0.9
                });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.castShadow = true;
                group.add(mesh);

                // Wireframe
                const wire = new THREE.LineSegments(
                    new THREE.EdgesGeometry(geo),
                    new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 })
                );
                group.add(wire);

                // Label sprite
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.roundRect(0, 0, 256, 64, 8);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(name, 128, 40);

                const tex = new THREE.CanvasTexture(canvas);
                const spriteMat = new THREE.SpriteMaterial({ map: tex });
                const sprite = new THREE.Sprite(spriteMat);
                sprite.position.set(0, cfg.size[1] + 1.5, 0);
                sprite.scale.set(4, 1, 1);
                group.add(sprite);

                group.position.set(...cfg.pos);
                group.name = name;
                group.userData = { type: cfg.type, baseColor: cfg.color, fault: false };

                scene.add(group);
                zoneControllers[name] = group;
            });
        }

        // ============================================
        // Create Network Connections
        // ============================================
        function createNetworkConnections() {
            // HPC to Zone Controllers (gold, thick)
            createNetworkLine('ACU_IT', 'Front-L-9692', 0xffd700, 0.08);
            createNetworkLine('ACU_IT', 'Front-R-9692', 0xffd700, 0.08);
            createNetworkLine('ACU_IT', 'Rear-9692', 0xffd700, 0.08);

            // Backbone (blue, thicker)
            createNetworkLine('Front-L-9692', 'Front-R-9692', 0x3b82f6, 0.1);

            // Sensor connections (green, thin)
            Object.entries(sensorZoneMap).forEach(([sensorName, zoneName]) => {
                createSensorLine(sensorName, zoneName);
            });
        }

        function createNetworkLine(from, to, color, radius) {
            const fromPos = new THREE.Vector3(...zoneConfig[from].pos);
            const toPos = new THREE.Vector3(...zoneConfig[to].pos);

            const curve = new THREE.CatmullRomCurve3([fromPos, toPos]);
            const geo = new THREE.TubeGeometry(curve, 16, radius, 8, false);
            const mat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.7
            });
            const tube = new THREE.Mesh(geo, mat);
            tube.name = `link-${from}-${to}`;
            tube.userData = { from, to, baseColor: color, fault: false };

            scene.add(tube);
            networkLines.push(tube);
        }

        function createSensorLine(sensorName, zoneName) {
            const sensor = sensors[sensorName];
            const zone = zoneControllers[zoneName];
            if (!sensor || !zone) return;

            const fromPos = sensor.position.clone();
            const toPos = new THREE.Vector3(...zoneConfig[zoneName].pos);

            const points = [fromPos, toPos];
            const geo = new THREE.BufferGeometry().setFromPoints(points);
            const mat = new THREE.LineBasicMaterial({
                color: 0x10b981,
                transparent: true,
                opacity: 0.4
            });
            const line = new THREE.Line(geo, mat);
            line.name = `sensor-link-${sensorName}`;
            line.userData = { sensor: sensorName, zone: zoneName };

            scene.add(line);
            networkLines.push(line);
        }

        // ============================================
        // Opacity Control
        // ============================================
        function setOpacity(val) {
            vehicleOpacity = val / 100;
            document.getElementById('opacityValue').textContent = val + '%';
            vehicleMeshes.forEach(m => {
                if (m.material) m.material.opacity = vehicleOpacity;
            });
        }

        // ============================================
        // Fault Injection (Realistic)
        // ============================================
        function injectFault(type) {
            if (state.status === 'recovering') return;

            state.status = 'critical';
            state.faults.add(type);
            updateStatusUI();

            document.querySelector(`[data-fault="${type}"]`).classList.add('active');
            document.getElementById('recoveryBtn').disabled = false;

            // Set target metrics for gradual transition
            state.targetMetrics = {
                ptpOffset: 2500 + Math.random() * 2000,  // 2.5-4.5 µs
                jitter: 800 + Math.random() * 400,       // 800-1200 ns
                packetLoss: 0.5 + Math.random() * 1.5,   // 0.5-2%
                crcErrors: 150 + Math.floor(Math.random() * 200)  // 150-350/s
            };

            switch(type) {
                case 'lidar':
                    setSensorFault('LiDAR-FL', true);
                    document.getElementById('ts-lidar').classList.add('fault');
                    document.getElementById('node-fl').classList.add('fault');
                    log('err', 'FAULT: LiDAR-FL (swp1) - No carrier detected');
                    log('warn', 'ieee802-dot1q-bridge: Port swp1 state changed to DISABLED');
                    log('info', 'Initiating sensor fusion fallback for Front-Left zone');
                    break;

                case 'camera':
                    setSensorFault('Cam-FL', true);
                    setSensorFault('Cam-SL1', true);
                    document.getElementById('ts-cam').classList.add('fault');
                    log('err', 'FAULT: Camera cluster FL - MIPI CSI link failure');
                    log('warn', 'Stream ID 0x0A01 - Bandwidth dropped to 0 Mbps');
                    log('info', 'Vision processing switching to degraded mode');
                    break;

                case 'backbone':
                    document.getElementById('link-fl-fr').classList.add('fault');
                    setNetworkFault('link-Front-L-9692-Front-R-9692', true);
                    log('err', 'FAULT: 10G backbone (sfp0) - Signal loss detected');
                    log('warn', 'ieee802-dot1cb-frer: Redundancy path A unavailable');
                    log('info', 'Rerouting traffic via HPC backbone');
                    break;

                case 'ptp':
                    state.targetMetrics.ptpOffset = 15000 + Math.random() * 10000; // 15-25 µs
                    log('err', 'FAULT: PTP sync lost - offset exceeds 1µs threshold');
                    log('warn', 'ieee1588-ptp: BMC election triggered');
                    log('info', 'TAS/CBS scheduling may be affected');
                    break;

                case 'zone':
                    document.getElementById('node-fl').classList.add('fault');
                    document.getElementById('link-hpc-fl').classList.add('fault');
                    setZoneFault('Front-L-9692', true);
                    setNetworkFault('link-ACU_IT-Front-L-9692', true);
                    ['LiDAR-FL', 'LiDAR-FC', 'Cam-FL', 'Cam-SL1', 'Cam-SL2', 'Radar-FL'].forEach(s => setSensorFault(s, true));
                    log('err', 'FAULT: Front-L zone controller (LAN9692) - Watchdog timeout');
                    log('warn', '6 sensors disconnected from network');
                    log('info', 'Emergency stop signal sent to ADAS controller');
                    break;
            }
        }

        function setSensorFault(name, fault) {
            const s = sensors[name];
            if (!s) return;
            s.userData.fault = fault;
            s.material.color.setHex(fault ? 0xdc3545 : s.userData.baseColor);
            s.material.emissive.setHex(fault ? 0xdc3545 : s.userData.baseColor);
        }

        function setZoneFault(name, fault) {
            const zone = zoneControllers[name];
            if (!zone) return;
            zone.userData.fault = fault;
            zone.children.forEach(child => {
                if (child.isMesh && child.material) {
                    child.material.color.setHex(fault ? 0xdc3545 : zone.userData.baseColor);
                }
            });
        }

        function setNetworkFault(lineName, fault) {
            const line = networkLines.find(l => l.name === lineName);
            if (!line) return;
            line.userData.fault = fault;
            if (line.material) {
                line.material.color.setHex(fault ? 0xdc3545 : line.userData.baseColor);
                line.material.opacity = fault ? 0.3 : 0.7;
            }
        }

        // ============================================
        // Recovery
        // ============================================
        function startRecovery() {
            if (state.status !== 'critical') return;

            state.status = 'recovering';
            updateStatusUI();

            const btn = document.getElementById('recoveryBtn');
            btn.classList.add('processing');
            btn.innerHTML = '<i class="fas fa-sync-alt"></i> Processing...';

            log('info', 'Initiating CORECONF policy-based recovery...');

            setTimeout(() => log('cmd', 'coreconf-client patch /policy/auto-recovery.yaml'), 400);
            setTimeout(() => log('info', 'Resetting TAS gate control list...'), 1000);
            setTimeout(() => log('cmd', 'tc qdisc replace dev swp1 parent root taprio ...'), 1500);
            setTimeout(() => log('info', 'Re-establishing PTP synchronization...'), 2200);
            setTimeout(() => log('cmd', 'pmc -u -b 0 "SET GRANDMASTER_SETTINGS_NP ..."'), 2800);

            // Gradual recovery
            state.targetMetrics = {
                ptpOffset: 40 + Math.random() * 30,
                jitter: 10 + Math.random() * 10,
                packetLoss: 0,
                crcErrors: 0
            };

            setTimeout(() => {
                state.status = 'normal';
                state.faults.clear();

                document.querySelectorAll('.fault-btn.active').forEach(e => e.classList.remove('active'));
                document.querySelectorAll('.fault').forEach(e => e.classList.remove('fault'));

                // Reset sensors
                Object.values(sensors).forEach(s => {
                    s.userData.fault = false;
                    s.material.color.setHex(s.userData.baseColor);
                    s.material.emissive.setHex(s.userData.baseColor);
                });

                // Reset zone controllers
                Object.values(zoneControllers).forEach(zone => {
                    zone.userData.fault = false;
                    zone.children.forEach(child => {
                        if (child.isMesh && child.material) {
                            child.material.color.setHex(zone.userData.baseColor);
                        }
                    });
                });

                // Reset network lines
                networkLines.forEach(line => {
                    line.userData.fault = false;
                    if (line.material) {
                        line.material.color.setHex(line.userData.baseColor || 0x10b981);
                        line.material.opacity = line.userData.baseColor ? 0.7 : 0.4;
                    }
                });

                btn.classList.remove('processing');
                btn.innerHTML = '<i class="fas fa-sync-alt"></i> Auto-Reconfigure';
                btn.disabled = true;

                updateStatusUI();
                log('ok', 'Recovery complete - all systems operational');
                log('ok', 'TSN streams restored, network topology online');
            }, 4000);
        }

        // ============================================
        // UI Updates
        // ============================================
        function updateStatusUI() {
            const pill = document.getElementById('statusPill');
            const text = document.getElementById('statusText');

            pill.className = 'status-pill ' + state.status;
            text.textContent = state.status === 'normal' ? 'Operational' :
                               state.status === 'critical' ? 'Critical' : 'Recovering';
        }

        function updateMetricsUI() {
            const m = state.metrics;

            // PTP Offset
            const ptpEl = document.getElementById('mPtp');
            if (m.ptpOffset < 100) {
                ptpEl.innerHTML = Math.round(m.ptpOffset) + '<span class="metric-unit">ns</span>';
                ptpEl.className = 'metric-value good';
            } else if (m.ptpOffset < 1000) {
                ptpEl.innerHTML = Math.round(m.ptpOffset) + '<span class="metric-unit">ns</span>';
                ptpEl.className = 'metric-value warn';
            } else {
                ptpEl.innerHTML = (m.ptpOffset / 1000).toFixed(1) + '<span class="metric-unit">µs</span>';
                ptpEl.className = 'metric-value bad';
            }

            // Jitter
            const jitEl = document.getElementById('mJitter');
            if (m.jitter < 50) {
                jitEl.innerHTML = Math.round(m.jitter) + '<span class="metric-unit">ns</span>';
                jitEl.className = 'metric-value good';
            } else if (m.jitter < 500) {
                jitEl.innerHTML = Math.round(m.jitter) + '<span class="metric-unit">ns</span>';
                jitEl.className = 'metric-value warn';
            } else {
                jitEl.innerHTML = (m.jitter / 1000).toFixed(2) + '<span class="metric-unit">µs</span>';
                jitEl.className = 'metric-value bad';
            }

            // Packet Loss
            const lossEl = document.getElementById('mLoss');
            lossEl.innerHTML = m.packetLoss.toFixed(3) + '<span class="metric-unit">%</span>';
            lossEl.className = 'metric-value ' + (m.packetLoss === 0 ? 'good' : m.packetLoss < 0.1 ? 'warn' : 'bad');

            // CRC Errors
            const crcEl = document.getElementById('mCrc');
            crcEl.innerHTML = Math.round(m.crcErrors) + '<span class="metric-unit">/s</span>';
            crcEl.className = 'metric-value ' + (m.crcErrors === 0 ? 'good' : m.crcErrors < 10 ? 'warn' : 'bad');
        }

        // Gradual metric transitions
        function updateMetrics() {
            const m = state.metrics;
            const t = state.targetMetrics;

            if (t) {
                m.ptpOffset += (t.ptpOffset - m.ptpOffset) * 0.1;
                m.jitter += (t.jitter - m.jitter) * 0.1;
                m.packetLoss += (t.packetLoss - m.packetLoss) * 0.1;
                m.crcErrors += (t.crcErrors - m.crcErrors) * 0.1;
            } else {
                // Normal fluctuation
                m.ptpOffset = 40 + Math.random() * 30 + Math.sin(Date.now() / 1000) * 10;
                m.jitter = 10 + Math.random() * 10;
                m.packetLoss = 0;
                m.crcErrors = 0;
            }

            updateMetricsUI();
        }

        // ============================================
        // Logging
        // ============================================
        function log(type, msg) {
            const time = new Date().toLocaleTimeString('en-US', { hour12: false });
            const logs = document.getElementById('logs');
            const div = document.createElement('div');
            div.className = 'log';
            div.innerHTML = `<span class="log-time">${time}</span><span class="log-msg ${type}">${msg}</span>`;
            logs.appendChild(div);
            logs.scrollTop = logs.scrollHeight;
        }

        // ============================================
        // Chart
        // ============================================
        const chartCanvas = document.getElementById('ptpChart');
        const ctx = chartCanvas.getContext('2d');
        const chartData = Array(60).fill(48);

        function drawChart() {
            const w = chartCanvas.width = chartCanvas.clientWidth * 2;
            const h = chartCanvas.height = chartCanvas.clientHeight * 2;
            ctx.setTransform(2, 0, 0, 2, 0, 0);

            const width = w / 2;
            const height = h / 2;

            ctx.clearRect(0, 0, width, height);

            // Adaptive scale
            const maxVal = Math.max(...chartData, 100);
            const color = state.status === 'critical' ? '#dc3545' : '#0d6efd';

            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 1.5;

            chartData.forEach((v, i) => {
                const x = (width / (chartData.length - 1)) * i;
                const y = height - 4 - (v / maxVal) * (height - 8);
                i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
            });
            ctx.stroke();

            ctx.lineTo(width, height);
            ctx.lineTo(0, height);
            ctx.closePath();

            const grad = ctx.createLinearGradient(0, 0, 0, height);
            grad.addColorStop(0, color + '30');
            grad.addColorStop(1, color + '00');
            ctx.fillStyle = grad;
            ctx.fill();
        }

        function updateChart() {
            chartData.shift();
            chartData.push(state.metrics.ptpOffset);

            const chartVal = document.getElementById('chartVal');
            const v = state.metrics.ptpOffset;
            chartVal.textContent = v < 1000 ? Math.round(v) + ' ns' : (v / 1000).toFixed(2) + ' µs';
            chartVal.style.color = state.status === 'critical' ? '#dc3545' : '#212529';

            drawChart();
        }

        // ============================================
        // Animation
        // ============================================
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            sensorMeshes.forEach(s => {
                s.material.emissiveIntensity = s.userData.fault
                    ? 0.3 + Math.sin(time * 10) * 0.3
                    : 0.2 + Math.sin(time * 2) * 0.1;
            });

            controls.update();
            renderer.render(scene, camera);
        }

        // ============================================
        // Init
        // ============================================
        function updateClock() {
            document.getElementById('clock').textContent =
                new Date().toLocaleTimeString('en-US', { hour12: false });
        }

        setInterval(updateClock, 1000);
        setInterval(updateMetrics, 200);
        setInterval(updateChart, 500);

        window.addEventListener('resize', () => {
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        });

        updateClock();
        drawChart();
        animate();
    </script>
</body>
</html>
