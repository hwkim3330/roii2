<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ROii2 - Dark Mode</title>
    <script src="libs/three.min.js"></script>
    <script src="libs/OrbitControls.js"></script>
    <script src="libs/GLTFLoader.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Courier New', monospace; background: #000; overflow: hidden; }
        #canvas3d { width: 100vw; height: 100vh; }

        .hud { position: fixed; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; }

        .header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8) 0%, transparent 100%);
        }
        .title h1 {
            font-size: 24px;
            font-weight: 400;
            color: #0ff;
            text-shadow: 0 0 20px #0ff, 0 0 40px #0ff;
            letter-spacing: 8px;
        }
        .title p { font-size: 10px; color: #0ff; opacity: 0.6; letter-spacing: 4px; margin-top: 4px; }

        .stats {
            display: flex;
            gap: 30px;
        }
        .stat { text-align: center; }
        .stat-value {
            font-size: 36px;
            color: #0f0;
            text-shadow: 0 0 15px #0f0;
        }
        .stat-label { font-size: 9px; color: #0f0; opacity: 0.6; letter-spacing: 2px; }

        .version-links {
            position: absolute;
            top: 20px;
            right: 30px;
            display: flex;
            gap: 8px;
            pointer-events: auto;
        }
        .version-link {
            padding: 8px 14px;
            background: transparent;
            border: 1px solid #0ff;
            color: #0ff;
            text-decoration: none;
            font-size: 11px;
            transition: all 0.3s;
        }
        .version-link:hover { background: #0ff; color: #000; box-shadow: 0 0 20px #0ff; }
        .version-link.active { background: #0ff; color: #000; }

        .controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            pointer-events: auto;
        }
        .control-btn {
            width: 50px;
            height: 50px;
            background: transparent;
            border: 1px solid #0f0;
            color: #0f0;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .control-btn:hover { background: #0f0; color: #000; box-shadow: 0 0 20px #0f0; }
        .control-btn.active { background: #0f0; color: #000; }

        .fault-panel {
            position: absolute;
            left: 30px;
            bottom: 100px;
            width: 280px;
            border: 1px solid #f00;
            background: rgba(0,0,0,0.9);
            display: none;
            pointer-events: auto;
        }
        .fault-panel.visible { display: block; }
        .fault-header {
            padding: 12px 16px;
            border-bottom: 1px solid #f00;
            color: #f00;
            font-size: 11px;
            letter-spacing: 2px;
            text-shadow: 0 0 10px #f00;
        }
        .fault-item {
            padding: 12px 16px;
            border-bottom: 1px solid rgba(255,0,0,0.3);
            cursor: pointer;
            transition: all 0.2s;
        }
        .fault-item:hover { background: rgba(255,0,0,0.1); }
        .fault-item.active { background: rgba(255,0,0,0.2); }
        .fault-name { color: #f00; font-size: 11px; }
        .fault-desc { color: #666; font-size: 9px; margin-top: 4px; }

        .scanline {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,255,255,0.03) 2px, rgba(0,255,255,0.03) 4px);
            pointer-events: none;
            z-index: 1000;
        }

        .corner { position: absolute; width: 30px; height: 30px; border-color: #0ff; border-style: solid; }
        .corner.tl { top: 10px; left: 10px; border-width: 2px 0 0 2px; }
        .corner.tr { top: 10px; right: 10px; border-width: 2px 2px 0 0; }
        .corner.bl { bottom: 10px; left: 10px; border-width: 0 0 2px 2px; }
        .corner.br { bottom: 10px; right: 10px; border-width: 0 2px 2px 0; }

        .toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            font-size: 12px;
            opacity: 0;
            transition: all 0.3s;
        }
        .toast.visible { opacity: 1; }
    </style>
</head>
<body>
    <div id="canvas3d"></div>
    <div class="scanline"></div>

    <div class="hud">
        <div class="corner tl"></div>
        <div class="corner tr"></div>
        <div class="corner bl"></div>
        <div class="corner br"></div>

        <div class="header">
            <div class="title">
                <h1>ROii2</h1>
                <p>AUTOMOTIVE TSN NETWORK</p>
            </div>
            <div class="stats">
                <div class="stat"><div class="stat-value" id="deviceCount">21</div><div class="stat-label">NODES</div></div>
                <div class="stat"><div class="stat-value" id="linkCount">22</div><div class="stat-label">LINKS</div></div>
                <div class="stat"><div class="stat-value" id="bandwidth">57</div><div class="stat-label">GBPS</div></div>
            </div>
        </div>

        <div class="version-links">
            <a href="index.html" class="version-link"><i class="fas fa-project-diagram"></i></a>
            <a href="drive.html" class="version-link"><i class="fas fa-gamepad"></i></a>
            <a href="dark.html" class="version-link active"><i class="fas fa-moon"></i></a>
        </div>

        <div class="controls">
            <button class="control-btn" id="rotateBtn"><i class="fas fa-sync"></i></button>
            <button class="control-btn" id="resetBtn"><i class="fas fa-crosshairs"></i></button>
            <button class="control-btn" id="faultBtn"><i class="fas fa-bolt"></i></button>
            <button class="control-btn" id="loadBtn"><i class="fas fa-car"></i></button>
        </div>

        <div class="fault-panel" id="faultPanel">
            <div class="fault-header"><i class="fas fa-exclamation-triangle"></i> FAULT INJECTION</div>
            <div class="fault-item" data-fault="front-backbone"><div class="fault-name">FRONT 10G BACKBONE</div><div class="fault-desc">Front-L ↔ Front-R link failure</div></div>
            <div class="fault-item" data-fault="front-l-link"><div class="fault-name">FRONT-L → HPC LINK</div><div class="fault-desc">Zone controller link failure</div></div>
            <div class="fault-item" data-fault="sensor"><div class="fault-name">LiDAR-FL SENSOR</div><div class="fault-desc">Sensor malfunction</div></div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <script>
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000008);
    scene.fog = new THREE.Fog(0x000008, 60, 200);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
    camera.position.set(50, 35, 60);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('canvas3d').appendChild(renderer.domElement);

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.mouseButtons = { LEFT: null, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.ROTATE };

    // Neon lighting
    scene.add(new THREE.AmbientLight(0x111122, 0.3));
    const light1 = new THREE.PointLight(0x00ffff, 1, 100);
    light1.position.set(30, 30, 30);
    scene.add(light1);
    const light2 = new THREE.PointLight(0x00ff00, 0.5, 100);
    light2.position.set(-30, 20, -30);
    scene.add(light2);

    // Neon grid
    const grid = new THREE.GridHelper(200, 40, 0x00ffff, 0x001a1a);
    grid.material.opacity = 0.4;
    grid.material.transparent = true;
    scene.add(grid);

    const state = { vehicleGroup: new THREE.Group(), devices: new Map(), connections: [], deviceCounter: 1, activeFaults: new Set() };
    scene.add(state.vehicleGroup);

    const templates = {
        lan9692: { color: 0x00ff00, size: [4, 2, 4] },
        hpc: { color: 0xff0066, size: [5, 2.5, 5] },
        camera: { color: 0xffff00, size: [0.8, 0.8, 0.8] },
        lidar: { color: 0x00ffff, size: [1.2, 1.2, 1.2] },
        radar: { color: 0xff00ff, size: [1.2, 1.2, 1.2] }
    };

    function createVehicle() {
        const loader = new THREE.GLTFLoader();
        loader.load('./roii.glb', (gltf) => {
            const model = gltf.scene;
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            const scale = 40 / Math.max(size.x, size.y, size.z);
            model.scale.set(scale, scale, scale);
            model.position.set(-center.x, -center.y + size.y * scale * 0.5, -center.z);
            model.traverse((c) => {
                if (c.isMesh) {
                    c.material = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, opacity: 0.3, transparent: true });
                }
            });
            state.vehicleGroup.add(model);
        });
    }

    function addDevice(type, position, label) {
        const t = templates[type];
        const id = `dev-${state.deviceCounter++}`;
        const device = { id, type, label, position: position.clone(), status: 'normal' };

        const geo = new THREE.BoxGeometry(...t.size);
        const mat = new THREE.MeshBasicMaterial({ color: t.color, wireframe: true });
        const group = new THREE.Group();
        group.add(new THREE.Mesh(geo, mat));
        // Glow
        const glowGeo = new THREE.BoxGeometry(t.size[0] + 0.2, t.size[1] + 0.2, t.size[2] + 0.2);
        const glowMat = new THREE.MeshBasicMaterial({ color: t.color, transparent: true, opacity: 0.15 });
        group.add(new THREE.Mesh(glowGeo, glowMat));
        group.position.copy(position);
        group.userData = { device };
        device.mesh = group;

        state.vehicleGroup.add(group);
        state.devices.set(id, device);
        return device;
    }

    function createConnection(from, to) {
        let color = from.type === 'lan9692' && to.type === 'lan9692' ? 0x00ffff :
                    from.type === 'hpc' || to.type === 'hpc' ? 0xffff00 : 0x00ff00;
        const bw = (from.type === 'hpc' || to.type === 'hpc' || (from.type === 'lan9692' && to.type === 'lan9692')) ? '10G' : '1G';

        const curve = new THREE.CatmullRomCurve3([from.position.clone(), to.position.clone()]);
        const tube = new THREE.Mesh(
            new THREE.TubeGeometry(curve, 16, bw === '10G' ? 0.12 : 0.05, 8, false),
            new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.6 })
        );
        state.vehicleGroup.add(tube);

        const particles = [];
        const count = bw === '10G' ? 4 : 2;
        for (let i = 0; i < count; i++) {
            const p = new THREE.Mesh(new THREE.SphereGeometry(0.2, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            p.userData = { t: i / count, curve };
            state.vehicleGroup.add(p);
            particles.push(p);
        }

        const conn = { from, to, tube, particles, bandwidth: bw, status: 'normal', originalColor: color };
        state.connections.push(conn);
        return conn;
    }

    function loadScenario() {
        state.devices.forEach(d => state.vehicleGroup.remove(d.mesh));
        state.connections.forEach(c => { state.vehicleGroup.remove(c.tube); c.particles.forEach(p => state.vehicleGroup.remove(p)); });
        state.devices.clear();
        state.connections = [];
        state.deviceCounter = 1;

        createVehicle();

        const acuIT = addDevice('hpc', new THREE.Vector3(0, 4, 0), 'ACU_IT');
        const frontL = addDevice('lan9692', new THREE.Vector3(-3.5, 4, 10), 'Front-L-9692');
        const frontR = addDevice('lan9692', new THREE.Vector3(3.5, 4, 10), 'Front-R-9692');
        const rear = addDevice('lan9692', new THREE.Vector3(0, 4, -10), 'Rear-9692');

        // Updated sensor positions (matched with drive.html)
        [[-8.5, 10, 16.2, 'LiDAR-FL'], [8.5, 10, 16.2, 'LiDAR-FR'], [0, 5.5, 18.5, 'LiDAR-FC'], [0, 5.5, -18.5, 'LiDAR-RC']].forEach(p => addDevice('lidar', new THREE.Vector3(p[0], p[1], p[2]), p[3]));
        [[0, 10.5, 18.5, 'Cam-FC'], [-2.5, 10.5, 18.5, 'Cam-FL'], [2.5, 10.5, 18.5, 'Cam-FR'], [-8.5, 11, 16.5, 'Cam-SL1'], [8.5, 11, 16.5, 'Cam-SR1'], [-8.5, 11, 15.9, 'Cam-SL2'], [8.5, 11, 15.9, 'Cam-SR2'], [0, 10.5, -18.5, 'Cam-RC']].forEach(p => addDevice('camera', new THREE.Vector3(p[0], p[1], p[2]), p[3]));
        [[0, 3, 18.5, 'Radar-FC'], [-7, 3, 17.5, 'Radar-FL'], [7, 3, 17.5, 'Radar-FR'], [-7, 3, -17.5, 'Radar-RL'], [7, 3, -17.5, 'Radar-RR']].forEach(p => addDevice('radar', new THREE.Vector3(p[0], p[1], p[2]), p[3]));

        createConnection(frontL, acuIT); createConnection(frontR, acuIT); createConnection(rear, acuIT); createConnection(frontL, frontR);

        state.devices.forEach(d => {
            if (d.type === 'lidar' || d.type === 'camera' || d.type === 'radar') {
                const zone = d.position.z > 0 ? (d.position.x < 0 ? frontL : frontR) : rear;
                createConnection(zone, d);
            }
        });

        updateStats();
        showToast('SYSTEM LOADED');
    }

    function updateStats() {
        document.getElementById('deviceCount').textContent = state.devices.size;
        document.getElementById('linkCount').textContent = state.connections.length;
        let bw = 0;
        state.connections.forEach(c => bw += c.bandwidth === '10G' ? 10 : 1);
        document.getElementById('bandwidth').textContent = bw;
    }

    function showToast(msg) {
        const toast = document.getElementById('toast');
        toast.textContent = msg;
        toast.classList.add('visible');
        setTimeout(() => toast.classList.remove('visible'), 2000);
    }

    function injectFault(type) {
        if (state.activeFaults.has(type)) {
            state.activeFaults.delete(type);
            state.connections.forEach(c => {
                c.tube.material.color.setHex(c.originalColor);
                c.tube.material.opacity = 0.6;
                c.particles.forEach(p => p.visible = true);
            });
            state.devices.forEach(d => {
                if (d.label === 'LiDAR-FL') d.mesh.children[0].material.color.setHex(templates.lidar.color);
            });
            document.querySelector(`[data-fault="${type}"]`).classList.remove('active');
            showToast('FAULT CLEARED');
            return;
        }

        state.activeFaults.add(type);
        if (type === 'sensor') {
            state.devices.forEach(d => { if (d.label === 'LiDAR-FL') d.mesh.children[0].material.color.setHex(0xff0000); });
        } else {
            state.connections.forEach(c => {
                let match = false;
                if (type === 'front-backbone' && c.from.label.includes('Front') && c.to.label.includes('Front') && c.from.type === 'lan9692' && c.to.type === 'lan9692') match = true;
                if (type === 'front-l-link' && ((c.from.label === 'Front-L-9692' && c.to.label === 'ACU_IT') || (c.to.label === 'Front-L-9692' && c.from.label === 'ACU_IT'))) match = true;
                if (match) { c.tube.material.color.setHex(0xff0000); c.tube.material.opacity = 0.3; c.particles.forEach(p => p.visible = false); }
            });
        }
        document.querySelector(`[data-fault="${type}"]`).classList.add('active');
        showToast('FAULT INJECTED');
    }

    document.getElementById('rotateBtn').addEventListener('click', function() { controls.autoRotate = !controls.autoRotate; this.classList.toggle('active'); });
    document.getElementById('resetBtn').addEventListener('click', () => { camera.position.set(50, 35, 60); controls.target.set(0, 0, 0); });
    document.getElementById('faultBtn').addEventListener('click', () => document.getElementById('faultPanel').classList.toggle('visible'));
    document.getElementById('loadBtn').addEventListener('click', loadScenario);
    document.querySelectorAll('.fault-item').forEach(item => item.addEventListener('click', () => injectFault(item.dataset.fault)));

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        state.connections.forEach(c => {
            if (c.particles[0].visible) {
                c.particles.forEach(p => {
                    p.userData.t += 0.012;
                    if (p.userData.t > 1) p.userData.t = 0;
                    p.position.copy(p.userData.curve.getPoint(p.userData.t));
                });
            }
        });
        renderer.render(scene, camera);
    }

    loadScenario();
    animate();
    </script>
</body>
</html>
