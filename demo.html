<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ROii2 - Auto Demo Presentation</title>
    <script src="libs/three.min.js"></script>
    <script src="libs/GLTFLoader.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600;700&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Rajdhani', sans-serif; background: #0a0a12; overflow: hidden; color: white; }
        #container { width: 100vw; height: 100vh; position: relative; }
        canvas { display: block; }

        .overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            background: linear-gradient(180deg, rgba(0,0,0,0.3) 0%, transparent 20%, transparent 80%, rgba(0,0,0,0.5) 100%);
        }

        .header {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }
        .header h1 {
            font-size: 28px;
            font-weight: 700;
            color: #00d4ff;
            text-shadow: 0 0 30px #00d4ff;
            letter-spacing: 8px;
        }
        .header p { font-size: 12px; color: #668; letter-spacing: 4px; margin-top: 5px; }

        .scene-info {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            transition: all 0.5s;
        }
        .scene-title {
            font-size: 36px;
            font-weight: 700;
            color: white;
            text-shadow: 0 0 20px rgba(0,212,255,0.5);
            margin-bottom: 10px;
        }
        .scene-desc {
            font-size: 16px;
            color: #88a;
            max-width: 600px;
        }

        .progress-bar {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #00ff88);
            border-radius: 2px;
            width: 0%;
            transition: width 0.1s linear;
        }

        .scene-dots {
            position: absolute;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }
        .scene-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.3s;
        }
        .scene-dot.active { background: #00d4ff; box-shadow: 0 0 10px #00d4ff; }
        .scene-dot:hover { background: rgba(255,255,255,0.5); }

        .stats-panel {
            position: absolute;
            top: 100px;
            right: 30px;
            background: rgba(0,20,40,0.8);
            border: 1px solid #00d4ff40;
            border-radius: 10px;
            padding: 20px;
            min-width: 200px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            font-size: 14px;
        }
        .stat-label { color: #668; }
        .stat-value { color: #00d4ff; font-weight: 600; }

        .sensor-legend {
            position: absolute;
            top: 100px;
            left: 30px;
            background: rgba(0,20,40,0.8);
            border: 1px solid #00d4ff40;
            border-radius: 10px;
            padding: 15px 20px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            font-size: 13px;
        }
        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .controls {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: flex;
            gap: 10px;
            pointer-events: auto;
        }
        .control-btn {
            background: rgba(0,212,255,0.2);
            border: 1px solid #00d4ff;
            color: #00d4ff;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
            transition: all 0.3s;
        }
        .control-btn:hover { background: rgba(0,212,255,0.4); }
        .control-btn.active { background: #00d4ff; color: #000; }
    </style>
</head>
<body>
    <div id="container">
        <div class="overlay"></div>

        <div class="header">
            <h1>ROii2 TSN DEMO</h1>
            <p>AUTOMOTIVE NETWORK VISUALIZATION</p>
        </div>

        <div class="sensor-legend">
            <div class="legend-item"><div class="legend-dot" style="background:#10B981"></div>LiDAR (4)</div>
            <div class="legend-item"><div class="legend-dot" style="background:#d66b00"></div>Camera (8)</div>
            <div class="legend-item"><div class="legend-dot" style="background:#952aff"></div>Radar (5)</div>
            <div class="legend-item"><div class="legend-dot" style="background:#3B82F6"></div>Zone Controller</div>
            <div class="legend-item"><div class="legend-dot" style="background:#FFD700"></div>Central Gateway</div>
        </div>

        <div class="stats-panel">
            <div class="stat-row"><span class="stat-label">Bandwidth</span><span class="stat-value" id="bandwidth">10 Gbps</span></div>
            <div class="stat-row"><span class="stat-label">Latency</span><span class="stat-value" id="latency">2.1 ms</span></div>
            <div class="stat-row"><span class="stat-label">Packets/s</span><span class="stat-value" id="packets">125,000</span></div>
            <div class="stat-row"><span class="stat-label">Jitter</span><span class="stat-value" id="jitter">0.05 ms</span></div>
        </div>

        <div class="scene-info">
            <div class="scene-title" id="sceneTitle">Network Overview</div>
            <div class="scene-desc" id="sceneDesc">Complete TSN network topology with all sensors and controllers</div>
        </div>

        <div class="scene-dots" id="sceneDots"></div>
        <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>

        <div class="controls">
            <button class="control-btn active" id="playBtn">▶ PLAY</button>
            <button class="control-btn" id="prevBtn">◀ PREV</button>
            <button class="control-btn" id="nextBtn">NEXT ▶</button>
        </div>
    </div>

    <script>
    const SCENES = [
        {
            title: "Network Overview",
            desc: "Complete TSN network topology with 17 sensors connected through zone controllers",
            camera: { pos: [60, 40, 60], target: [0, 0, 0] },
            highlight: null,
            rotation: true
        },
        {
            title: "Front Sensor Array",
            desc: "4 LiDAR + 3 Camera + 3 Radar sensors provide 360° coverage for autonomous navigation",
            camera: { pos: [0, 25, 50], target: [0, 8, 18] },
            highlight: 'front',
            rotation: false
        },
        {
            title: "Side Coverage",
            desc: "Side-mounted cameras enable lane change assistance and blind spot monitoring",
            camera: { pos: [40, 20, 0], target: [0, 8, 0] },
            highlight: 'side',
            rotation: false
        },
        {
            title: "Rear Sensors",
            desc: "Rear LiDAR, cameras and radars support reverse driving and rear collision avoidance",
            camera: { pos: [0, 25, -50], target: [0, 8, -18] },
            highlight: 'rear',
            rotation: false
        },
        {
            title: "Central Gateway",
            desc: "LAN9692 gateway aggregates all zone data with 10Gbps backbone connectivity",
            camera: { pos: [30, 30, 30], target: [0, 4, 0] },
            highlight: 'gateway',
            rotation: false
        },
        {
            title: "Data Flow",
            desc: "Real-time sensor fusion processes 125,000 packets per second with < 3ms latency",
            camera: { pos: [50, 50, 50], target: [0, 5, 0] },
            highlight: 'flow',
            rotation: true
        }
    ];

    let currentScene = 0;
    let isPlaying = true;
    let sceneProgress = 0;
    const SCENE_DURATION = 8000; // 8 seconds per scene

    // Three.js setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a12);
    scene.fog = new THREE.FogExp2(0x0a0a12, 0.006);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
    camera.position.set(60, 40, 60);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    document.getElementById('container').insertBefore(renderer.domElement, document.querySelector('.overlay'));

    // Lighting
    scene.add(new THREE.AmbientLight(0x334455, 0.5));
    const mainLight = new THREE.DirectionalLight(0xffffff, 1);
    mainLight.position.set(30, 50, 30);
    mainLight.castShadow = true;
    scene.add(mainLight);

    // Grid
    const grid = new THREE.GridHelper(100, 50, 0x00d4ff, 0x112233);
    grid.material.opacity = 0.3;
    grid.material.transparent = true;
    scene.add(grid);

    // Vehicle model
    const vehicleGroup = new THREE.Group();
    scene.add(vehicleGroup);

    const loader = new THREE.GLTFLoader();
    loader.load('roii.glb', (gltf) => {
        const model = gltf.scene;
        const box = new THREE.Box3().setFromObject(model);
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());
        const scale = 8 / Math.max(size.x, size.y, size.z);
        model.scale.set(scale, scale, scale);
        model.position.set(-center.x * scale, size.y * scale * 0.5, -center.z * scale);
        model.traverse(child => {
            if (child.isMesh && child.material) {
                child.material.transparent = true;
                child.material.opacity = 0.4;
                if (child.material.color) child.material.color.multiplyScalar(1.5);
            }
        });
        vehicleGroup.add(model);
    });

    // Sensors and devices
    const devices = [];
    const connections = [];
    const particles = [];

    const SENSOR_CONFIG = {
        lidar: { color: 0x10B981, positions: [[-8.5, 10, 16.2], [8.5, 10, 16.2], [0, 5.5, 18.5], [0, 5.5, -18.5]] },
        camera: { color: 0xd66b00, positions: [[0, 10.5, 18.5], [0.6, 10.5, 18.5], [-0.6, 10.5, 18.5], [-8.5, 11, 16.5], [8.5, 11, 16.5], [-8.5, 11, 15.9], [8.5, 11, 15.9], [0, 9, -18.5]] },
        radar: { color: 0x952aff, positions: [[0, 7, 18.5], [-7, 6.5, 17.5], [7, 6.5, 17.5], [-7, 6.5, -18], [7, 6.5, -18]] },
        zone: { color: 0x3B82F6, positions: [[-3.5, 4, 10], [3.5, 4, 10], [0, 4, -10]] },
        gateway: { color: 0xFFD700, positions: [[0, 4, 0]] }
    };

    function createDevice(type, pos, index) {
        const config = SENSOR_CONFIG[type];
        const geo = type === 'lidar' ? new THREE.CylinderGeometry(0.8, 0.8, 1, 16) :
                   type === 'gateway' ? new THREE.BoxGeometry(3, 2, 3) :
                   type === 'zone' ? new THREE.BoxGeometry(2.5, 1.5, 2.5) :
                   new THREE.BoxGeometry(0.8, 0.8, 0.8);
        const mat = new THREE.MeshPhongMaterial({
            color: config.color,
            emissive: config.color,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.9
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(...pos);
        mesh.castShadow = true;

        // Glow ring
        const ringGeo = new THREE.RingGeometry(1, 1.3, 32);
        const ringMat = new THREE.MeshBasicMaterial({ color: config.color, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.rotation.x = -Math.PI / 2;
        ring.position.set(...pos);
        ring.position.y = 0.1;

        scene.add(mesh);
        scene.add(ring);

        const zone = pos[2] > 5 ? 'front' : (pos[2] < -5 ? 'rear' : 'center');
        devices.push({ mesh, ring, type, pos, zone, baseEmissive: 0.5 });

        return { mesh, pos };
    }

    // Create all devices
    Object.entries(SENSOR_CONFIG).forEach(([type, config]) => {
        config.positions.forEach((pos, i) => createDevice(type, pos, i));
    });

    // Create connections
    function createConnection(from, to, color) {
        const curve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(...from),
            new THREE.Vector3(...to)
        ]);
        const tubeGeo = new THREE.TubeGeometry(curve, 20, 0.05, 8, false);
        const tubeMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.4 });
        const tube = new THREE.Mesh(tubeGeo, tubeMat);
        scene.add(tube);
        connections.push({ tube, curve, color });

        // Flowing particles
        for (let i = 0; i < 2; i++) {
            const pGeo = new THREE.SphereGeometry(0.15, 8, 8);
            const pMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const particle = new THREE.Mesh(pGeo, pMat);
            particle.userData = { curve, progress: i * 0.5, speed: 0.3 + Math.random() * 0.2 };
            scene.add(particle);
            particles.push(particle);
        }
    }

    // Connect sensors to zones
    const frontZone = SENSOR_CONFIG.zone.positions[0];
    const frontZone2 = SENSOR_CONFIG.zone.positions[1];
    const rearZone = SENSOR_CONFIG.zone.positions[2];
    const gateway = SENSOR_CONFIG.gateway.positions[0];

    SENSOR_CONFIG.lidar.positions.slice(0, 2).forEach(p => createConnection(p, frontZone, 0x10B981));
    SENSOR_CONFIG.lidar.positions.slice(2, 3).forEach(p => createConnection(p, frontZone2, 0x10B981));
    SENSOR_CONFIG.lidar.positions.slice(3).forEach(p => createConnection(p, rearZone, 0x10B981));

    SENSOR_CONFIG.camera.positions.slice(0, 3).forEach(p => createConnection(p, frontZone2, 0xd66b00));
    SENSOR_CONFIG.camera.positions.slice(3, 5).forEach(p => createConnection(p, frontZone, 0xd66b00));
    SENSOR_CONFIG.camera.positions.slice(5, 7).forEach(p => createConnection(p, rearZone, 0xd66b00));
    SENSOR_CONFIG.camera.positions.slice(7).forEach(p => createConnection(p, rearZone, 0xd66b00));

    SENSOR_CONFIG.radar.positions.slice(0, 3).forEach(p => createConnection(p, frontZone2, 0x952aff));
    SENSOR_CONFIG.radar.positions.slice(3).forEach(p => createConnection(p, rearZone, 0x952aff));

    // Zone to gateway
    createConnection(frontZone, gateway, 0xFFD700);
    createConnection(frontZone2, gateway, 0xFFD700);
    createConnection(rearZone, gateway, 0xFFD700);

    // Create scene dots
    const dotsContainer = document.getElementById('sceneDots');
    SCENES.forEach((_, i) => {
        const dot = document.createElement('div');
        dot.className = 'scene-dot' + (i === 0 ? ' active' : '');
        dot.onclick = () => goToScene(i);
        dotsContainer.appendChild(dot);
    });

    function updateSceneUI() {
        const s = SCENES[currentScene];
        document.getElementById('sceneTitle').textContent = s.title;
        document.getElementById('sceneDesc').textContent = s.desc;

        document.querySelectorAll('.scene-dot').forEach((dot, i) => {
            dot.classList.toggle('active', i === currentScene);
        });

        // Highlight devices
        devices.forEach(d => {
            let highlighted = false;
            if (s.highlight === 'front' && d.zone === 'front') highlighted = true;
            if (s.highlight === 'rear' && d.zone === 'rear') highlighted = true;
            if (s.highlight === 'side' && d.type === 'camera' && Math.abs(d.pos[0]) > 5) highlighted = true;
            if (s.highlight === 'gateway' && (d.type === 'gateway' || d.type === 'zone')) highlighted = true;
            if (s.highlight === 'flow' || s.highlight === null) highlighted = true;

            d.mesh.material.emissiveIntensity = highlighted ? 0.8 : 0.2;
            d.mesh.material.opacity = highlighted ? 0.95 : 0.3;
            d.ring.material.opacity = highlighted ? 0.5 : 0.1;
        });
    }

    function goToScene(index) {
        currentScene = index;
        sceneProgress = 0;
        updateSceneUI();
    }

    function nextScene() {
        currentScene = (currentScene + 1) % SCENES.length;
        sceneProgress = 0;
        updateSceneUI();
    }

    function prevScene() {
        currentScene = (currentScene - 1 + SCENES.length) % SCENES.length;
        sceneProgress = 0;
        updateSceneUI();
    }

    // Controls
    document.getElementById('playBtn').onclick = function() {
        isPlaying = !isPlaying;
        this.textContent = isPlaying ? '▶ PLAY' : '⏸ PAUSE';
        this.classList.toggle('active', isPlaying);
    };
    document.getElementById('nextBtn').onclick = nextScene;
    document.getElementById('prevBtn').onclick = prevScene;

    // Animation
    let lastTime = 0;
    let rotationAngle = 0;

    function animate(time) {
        requestAnimationFrame(animate);
        const delta = (time - lastTime) / 1000;
        lastTime = time;

        if (isPlaying) {
            sceneProgress += delta * 1000;
            if (sceneProgress >= SCENE_DURATION) {
                nextScene();
            }
        }

        // Update progress bar
        document.getElementById('progressFill').style.width = (sceneProgress / SCENE_DURATION * 100) + '%';

        // Camera animation
        const s = SCENES[currentScene];
        const targetPos = new THREE.Vector3(...s.camera.pos);
        const targetLook = new THREE.Vector3(...s.camera.target);

        if (s.rotation) {
            rotationAngle += delta * 0.3;
            const dist = Math.sqrt(targetPos.x ** 2 + targetPos.z ** 2);
            targetPos.x = Math.cos(rotationAngle) * dist;
            targetPos.z = Math.sin(rotationAngle) * dist;
        }

        camera.position.lerp(targetPos, 0.02);
        const currentLook = new THREE.Vector3();
        camera.getWorldDirection(currentLook);
        camera.lookAt(targetLook);

        // Animate particles
        particles.forEach(p => {
            p.userData.progress += p.userData.speed * delta;
            if (p.userData.progress > 1) p.userData.progress = 0;
            const point = p.userData.curve.getPoint(p.userData.progress);
            p.position.copy(point);
            p.material.opacity = Math.sin(p.userData.progress * Math.PI);
        });

        // Animate rings
        devices.forEach(d => {
            d.ring.scale.setScalar(1 + Math.sin(time * 0.002 + d.pos[0]) * 0.1);
        });

        // Update stats
        document.getElementById('bandwidth').textContent = (9.5 + Math.random() * 0.5).toFixed(1) + ' Gbps';
        document.getElementById('latency').textContent = (2 + Math.random() * 0.5).toFixed(1) + ' ms';
        document.getElementById('packets').textContent = Math.floor(120000 + Math.random() * 10000).toLocaleString();
        document.getElementById('jitter').textContent = (0.03 + Math.random() * 0.04).toFixed(2) + ' ms';

        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    updateSceneUI();
    animate(0);
    </script>
</body>
</html>
