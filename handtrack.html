<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ROii2 - Hand Control</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #0a0a0f;
            --card: rgba(20, 20, 30, 0.9);
            --border: rgba(16, 185, 129, 0.3);
            --text: #f0f0f0;
            --text-muted: #64748b;
            --green: #10B981;
            --blue: #3B82F6;
            --red: #EF4444;
            --yellow: #F59E0B;
            --purple: #8B5CF6;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
            height: 100vh;
        }

        #canvas3d {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }

        /* Webcam Preview */
        .webcam-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 280px;
            height: 210px;
            border-radius: 16px;
            overflow: hidden;
            border: 2px solid var(--border);
            background: #000;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }

        #webcam {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #handCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            transform: scaleX(-1);
        }

        .webcam-status {
            position: absolute;
            top: 8px;
            left: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            background: rgba(0,0,0,0.7);
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--red);
            animation: pulse 1.5s infinite;
        }

        .status-dot.active { background: var(--green); }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Top HUD */
        .top-hud {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 20px;
            z-index: 100;
        }

        .logo-box {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 20px;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 12px;
        }

        .logo-box img { height: 24px; }
        .logo-box h1 { font-size: 16px; color: var(--green); }
        .logo-box span { font-size: 12px; color: var(--text-muted); }

        .mode-switch {
            display: flex;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
        }

        .mode-btn {
            padding: 12px 24px;
            background: transparent;
            border: none;
            color: var(--text-muted);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .mode-btn:hover { background: rgba(255,255,255,0.05); }
        .mode-btn.active {
            background: var(--green);
            color: #000;
        }

        /* Gesture Guide */
        .gesture-guide {
            position: fixed;
            top: 90px;
            right: 20px;
            width: 280px;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 16px;
            z-index: 100;
        }

        .guide-title {
            font-size: 12px;
            font-weight: 700;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .gesture-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .gesture-item:last-child { border: none; }

        .gesture-icon {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            background: rgba(16, 185, 129, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--green);
            font-size: 16px;
        }

        .gesture-info { flex: 1; }
        .gesture-name { font-size: 13px; font-weight: 600; }
        .gesture-desc { font-size: 11px; color: var(--text-muted); }

        /* Left Panel - Hand Status */
        .hand-panel {
            position: fixed;
            top: 90px;
            left: 20px;
            width: 260px;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 16px;
            z-index: 100;
        }

        .hand-status {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .hand-box {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 12px;
            text-align: center;
        }

        .hand-box.active { border: 1px solid var(--green); }

        .hand-label {
            font-size: 10px;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 6px;
        }

        .hand-gesture {
            font-size: 22px;
            margin-bottom: 4px;
        }

        .hand-action {
            font-size: 11px;
            font-weight: 600;
            color: var(--green);
        }

        /* Speed Panel (Drive Mode) */
        .speed-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 24px 40px;
            text-align: center;
            z-index: 100;
            display: none;
        }

        .speed-panel.visible { display: block; }

        .speed-value {
            font-size: 64px;
            font-weight: 700;
            color: var(--green);
            line-height: 1;
            font-variant-numeric: tabular-nums;
        }

        .speed-unit {
            font-size: 14px;
            color: var(--text-muted);
            margin-top: 4px;
        }

        /* Cursor */
        .hand-cursor {
            position: fixed;
            width: 40px;
            height: 40px;
            border: 3px solid var(--green);
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 0.2s, transform 0.1s;
        }

        .hand-cursor.visible { opacity: 1; }

        .hand-cursor::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            background: var(--green);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .hand-cursor.grabbing {
            border-color: var(--yellow);
            transform: translate(-50%, -50%) scale(1.3);
        }

        .hand-cursor.grabbing::before {
            background: var(--yellow);
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 250px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            padding: 14px 28px;
            background: var(--green);
            color: #000;
            border-radius: 12px;
            font-weight: 600;
            font-size: 14px;
            opacity: 0;
            transition: all 0.3s;
            z-index: 1000;
        }

        .toast.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Loading */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            transition: opacity 0.5s;
        }

        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top-color: var(--green);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .loading-text {
            margin-top: 20px;
            font-size: 14px;
            color: var(--text-muted);
        }

        /* Version Links */
        .version-nav {
            position: fixed;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 8px;
            z-index: 100;
        }

        .nav-link {
            padding: 10px 16px;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--green);
            text-decoration: none;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .nav-link:hover {
            background: rgba(16, 185, 129, 0.2);
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading MediaPipe Hand Tracking...</div>
    </div>

    <canvas id="canvas3d"></canvas>

    <div class="version-nav">
        <a href="index.html" class="nav-link"><i class="fas fa-project-diagram"></i> Network</a>
        <a href="drive.html" class="nav-link"><i class="fas fa-car"></i> Drive</a>
        <a href="fault.html" class="nav-link"><i class="fas fa-bolt"></i> Fault</a>
    </div>

    <div class="top-hud">
        <div class="logo-box">
            <img src="keti.png" alt="KETI">
            <h1>ROii2</h1>
            <span>Hand Control</span>
        </div>
        <div class="mode-switch">
            <button class="mode-btn active" data-mode="network" onclick="setMode('network')">
                <i class="fas fa-project-diagram"></i> Network
            </button>
            <button class="mode-btn" data-mode="drive" onclick="setMode('drive')">
                <i class="fas fa-gamepad"></i> Drive
            </button>
        </div>
    </div>

    <div class="hand-panel">
        <div class="guide-title"><i class="fas fa-hand"></i> Hand Detection</div>
        <div class="hand-status">
            <div class="hand-box" id="leftHand">
                <div class="hand-label">Left Hand</div>
                <div class="hand-gesture" id="leftGesture">-</div>
                <div class="hand-action" id="leftAction">Not detected</div>
            </div>
            <div class="hand-box" id="rightHand">
                <div class="hand-label">Right Hand</div>
                <div class="hand-gesture" id="rightGesture">-</div>
                <div class="hand-action" id="rightAction">Not detected</div>
            </div>
        </div>
    </div>

    <div class="gesture-guide">
        <div class="guide-title"><i class="fas fa-magic"></i> Gesture Controls</div>
        <div class="gesture-item">
            <div class="gesture-icon"><i class="fas fa-hand-paper"></i></div>
            <div class="gesture-info">
                <div class="gesture-name">Open Palm (Move)</div>
                <div class="gesture-desc">Rotate camera / Steer vehicle</div>
            </div>
        </div>
        <div class="gesture-item">
            <div class="gesture-icon"><i class="fas fa-hand-rock"></i></div>
            <div class="gesture-info">
                <div class="gesture-name">Fist (Action)</div>
                <div class="gesture-desc">Zoom in / Accelerate</div>
            </div>
        </div>
        <div class="gesture-item">
            <div class="gesture-icon"><i class="fas fa-hand-point-up"></i></div>
            <div class="gesture-info">
                <div class="gesture-name">Point (Select)</div>
                <div class="gesture-desc">Select device / Brake</div>
            </div>
        </div>
        <div class="gesture-item">
            <div class="gesture-icon"><i class="fas fa-hand-peace"></i></div>
            <div class="gesture-info">
                <div class="gesture-name">Peace (Reset)</div>
                <div class="gesture-desc">Reset view / Reset position</div>
            </div>
        </div>
    </div>

    <div class="webcam-container">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="handCanvas"></canvas>
        <div class="webcam-status">
            <div class="status-dot" id="webcamDot"></div>
            <span id="webcamStatus">Initializing...</span>
        </div>
    </div>

    <div class="speed-panel" id="speedPanel">
        <div class="speed-value" id="speedValue">0</div>
        <div class="speed-unit">km/h</div>
    </div>

    <div class="hand-cursor" id="handCursor"></div>
    <div class="toast" id="toast"></div>

    <!-- MediaPipe Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- Three.js -->
    <script src="libs/three.min.js"></script>
    <script src="libs/OrbitControls.js"></script>
    <script src="libs/GLTFLoader.js"></script>

    <script>
        // ============================================
        // State
        // ============================================
        const state = {
            mode: 'network', // 'network' or 'drive'
            handsDetected: { left: false, right: false },
            gestures: { left: 'none', right: 'none' },
            handPositions: { left: null, right: null },
            prevHandPositions: { left: null, right: null },
            velocity: { left: { x: 0, y: 0 }, right: { x: 0, y: 0 } },
            cameraRotation: { x: 0, y: 0 },
            zoom: 50,
            selectedDevice: null
        };

        const drive = {
            speed: 0,
            maxSpeed: 2.5,
            steering: 0,
            maxSteering: 0.035
        };

        // ============================================
        // Three.js Setup
        // ============================================
        const canvas = document.getElementById('canvas3d');
        const scene = new THREE.Scene();

        // Gradient background
        const bgCanvas = document.createElement('canvas');
        bgCanvas.width = 2;
        bgCanvas.height = 512;
        const bgCtx = bgCanvas.getContext('2d');
        const bgGrad = bgCtx.createLinearGradient(0, 0, 0, 512);
        bgGrad.addColorStop(0, '#000000');
        bgGrad.addColorStop(0.3, '#0a0a1a');
        bgGrad.addColorStop(0.6, '#0d1020');
        bgGrad.addColorStop(1, '#050510');
        bgCtx.fillStyle = bgGrad;
        bgCtx.fillRect(0, 0, 2, 512);
        scene.background = new THREE.CanvasTexture(bgCanvas);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(50, 35, 50);

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;

        // Lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));

        const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
        sunLight.position.set(50, 80, 50);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);

        scene.add(new THREE.DirectionalLight(0x8080ff, 0.3).position.set(-30, 30, -30));

        // Grid
        const gridHelper = new THREE.GridHelper(200, 50, 0x10B981, 0x0a3d2e);
        gridHelper.material.opacity = 0.3;
        gridHelper.material.transparent = true;
        scene.add(gridHelper);

        // Ground (for drive mode)
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(2000, 2000),
            new THREE.MeshStandardMaterial({ color: 0x111115, roughness: 0.9 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -1;
        ground.receiveShadow = true;
        scene.add(ground);

        // Road (for drive mode)
        const roadGroup = new THREE.Group();
        const roadMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
        const road = new THREE.Mesh(new THREE.PlaneGeometry(30, 4000), roadMat);
        road.rotation.x = -Math.PI / 2;
        road.position.y = -0.5;
        roadGroup.add(road);

        // Road lines
        const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const dashGeo = new THREE.PlaneGeometry(0.2, 6);
        for (let i = -2000; i < 2000; i += 15) {
            const dash = new THREE.Mesh(dashGeo, lineMat);
            dash.rotation.x = -Math.PI / 2;
            dash.position.set(0, -0.45, i);
            roadGroup.add(dash);
        }
        roadGroup.visible = false;
        scene.add(roadGroup);

        // ============================================
        // Sensor Configuration
        // ============================================
        const sensorConfig = {
            'LiDAR-FL': { pos: [-8.5, 10, 16.2], type: 'lidar', color: 0x10B981 },
            'LiDAR-FR': { pos: [8.5, 10, 16.2], type: 'lidar', color: 0x10B981 },
            'LiDAR-FC': { pos: [0, 5.5, 18.5], type: 'lidar', color: 0x10B981 },
            'LiDAR-RC': { pos: [0, 5.5, -18.5], type: 'lidar', color: 0x10B981 },
            'Cam-FC': { pos: [0, 10.5, 18.5], type: 'camera', color: 0x0dcaf0 },
            'Cam-FL': { pos: [0.6, 10.5, 18.5], type: 'camera', color: 0x0dcaf0 },
            'Cam-FR': { pos: [-0.6, 10.5, 18.5], type: 'camera', color: 0x0dcaf0 },
            'Cam-SL1': { pos: [-8.5, 11, 16.5], type: 'camera', color: 0x0dcaf0 },
            'Cam-SR1': { pos: [8.5, 11, 16.5], type: 'camera', color: 0x0dcaf0 },
            'Cam-SL2': { pos: [-8.5, 11, 15.9], type: 'camera', color: 0x0dcaf0 },
            'Cam-SR2': { pos: [8.5, 11, 15.9], type: 'camera', color: 0x0dcaf0 },
            'Cam-RC': { pos: [0, 9, -18.5], type: 'camera', color: 0x0dcaf0 },
            'Radar-FC': { pos: [0, 7, 18.5], type: 'radar', color: 0xF59E0B },
            'Radar-FL': { pos: [-7, 6.5, 17.5], type: 'radar', color: 0xF59E0B },
            'Radar-FR': { pos: [7, 6.5, 17.5], type: 'radar', color: 0xF59E0B },
            'Radar-RL': { pos: [-7, 6.5, -18], type: 'radar', color: 0xF59E0B },
            'Radar-RR': { pos: [7, 6.5, -18], type: 'radar', color: 0xF59E0B }
        };

        const zoneConfig = {
            'ACU_IT': { pos: [0, 4, 0], color: 0xffd700, size: [3, 1.5, 2] },
            'Front-L-9662': { pos: [-3.5, 4, 10], color: 0x3b82f6, size: [2, 1, 1.5] },
            'Front-R-9662': { pos: [3.5, 4, 10], color: 0x3b82f6, size: [2, 1, 1.5] },
            'Rear-9662': { pos: [0, 4, -10], color: 0x3b82f6, size: [2, 1, 1.5] }
        };

        // Objects
        const vehicleGroup = new THREE.Group();
        scene.add(vehicleGroup);

        const sensors = {};
        const zones = {};
        const networkLines = [];
        let vehicleMeshes = [];

        // ============================================
        // Load Vehicle & Create Network
        // ============================================
        function loadVehicle() {
            const loader = new THREE.GLTFLoader();
            loader.load('roii.glb', (gltf) => {
                const model = gltf.scene;
                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());

                const targetSize = 40;
                const scale = targetSize / Math.max(size.x, size.y, size.z);
                model.scale.set(scale, scale, scale);

                const scaledHeight = size.y * scale;
                model.position.set(-center.x * scale, -center.y * scale + scaledHeight * 0.5 + 0.5, -center.z * scale);

                model.traverse((child) => {
                    if (child.isMesh && child.material) {
                        child.material.transparent = true;
                        child.material.opacity = 0.8;
                        child.material.side = THREE.DoubleSide;
                        if (child.material.color) {
                            child.material.color.multiplyScalar(1.5);
                        }
                        child.material.emissive = new THREE.Color(0x333333);
                        child.material.emissiveIntensity = 0.2;
                        child.castShadow = true;
                        vehicleMeshes.push(child);
                    }
                });

                vehicleGroup.add(model);
                createSensors();
                createZones();
                createNetwork();

                showToast('Vehicle loaded - Use hand gestures to control!');
            });
        }

        function createSensors() {
            Object.entries(sensorConfig).forEach(([name, cfg]) => {
                let geo;
                if (cfg.type === 'lidar') geo = new THREE.OctahedronGeometry(0.6);
                else if (cfg.type === 'camera') geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                else geo = new THREE.ConeGeometry(0.4, 0.8, 8);

                const mat = new THREE.MeshStandardMaterial({
                    color: cfg.color,
                    emissive: cfg.color,
                    emissiveIntensity: 0.3,
                    metalness: 0.5,
                    roughness: 0.3
                });

                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(...cfg.pos);
                mesh.name = name;
                mesh.userData = { type: cfg.type, baseColor: cfg.color };

                vehicleGroup.add(mesh);
                sensors[name] = mesh;
            });
        }

        function createZones() {
            Object.entries(zoneConfig).forEach(([name, cfg]) => {
                const group = new THREE.Group();

                const geo = new THREE.BoxGeometry(...cfg.size);
                const mat = new THREE.MeshStandardMaterial({
                    color: cfg.color,
                    metalness: 0.7,
                    roughness: 0.3,
                    transparent: true,
                    opacity: 0.9
                });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.castShadow = true;
                group.add(mesh);

                // Wireframe
                const wire = new THREE.LineSegments(
                    new THREE.EdgesGeometry(geo),
                    new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 })
                );
                group.add(wire);

                // Label
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'rgba(0,0,0,0.8)';
                ctx.roundRect(0, 0, 256, 64, 8);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 22px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(name, 128, 40);

                const tex = new THREE.CanvasTexture(canvas);
                const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex }));
                sprite.position.set(0, cfg.size[1] + 1.5, 0);
                sprite.scale.set(4, 1, 1);
                group.add(sprite);

                group.position.set(...cfg.pos);
                group.name = name;
                group.userData = { baseColor: cfg.color };

                vehicleGroup.add(group);
                zones[name] = group;
            });
        }

        function createNetwork() {
            // Zone connections
            const zoneConns = [
                ['ACU_IT', 'Front-L-9662', 0xffd700],
                ['ACU_IT', 'Front-R-9662', 0xffd700],
                ['ACU_IT', 'Rear-9662', 0xffd700],
                ['Front-L-9662', 'Front-R-9662', 0x3b82f6]
            ];

            zoneConns.forEach(([from, to, color]) => {
                const fromPos = new THREE.Vector3(...zoneConfig[from].pos);
                const toPos = new THREE.Vector3(...zoneConfig[to].pos);
                const curve = new THREE.CatmullRomCurve3([fromPos, toPos]);
                const geo = new THREE.TubeGeometry(curve, 16, 0.08, 8, false);
                const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.7 });
                const tube = new THREE.Mesh(geo, mat);
                vehicleGroup.add(tube);
                networkLines.push(tube);
            });

            // Sensor connections
            const sensorZoneMap = {
                'LiDAR-FL': 'Front-L-9662', 'LiDAR-FC': 'Front-L-9662',
                'Cam-FL': 'Front-L-9662', 'Cam-SL1': 'Front-L-9662', 'Cam-SL2': 'Front-L-9662',
                'Radar-FL': 'Front-L-9662',
                'LiDAR-FR': 'Front-R-9662',
                'Cam-FC': 'Front-R-9662', 'Cam-FR': 'Front-R-9662', 'Cam-SR1': 'Front-R-9662', 'Cam-SR2': 'Front-R-9662',
                'Radar-FC': 'Front-R-9662', 'Radar-FR': 'Front-R-9662',
                'LiDAR-RC': 'Rear-9662', 'Cam-RC': 'Rear-9662',
                'Radar-RL': 'Rear-9662', 'Radar-RR': 'Rear-9662'
            };

            Object.entries(sensorZoneMap).forEach(([sensorName, zoneName]) => {
                const sensor = sensors[sensorName];
                if (!sensor) return;
                const fromPos = sensor.position.clone();
                const toPos = new THREE.Vector3(...zoneConfig[zoneName].pos);
                const geo = new THREE.BufferGeometry().setFromPoints([fromPos, toPos]);
                const mat = new THREE.LineBasicMaterial({ color: 0x10b981, transparent: true, opacity: 0.4 });
                const line = new THREE.Line(geo, mat);
                vehicleGroup.add(line);
                networkLines.push(line);
            });
        }

        loadVehicle();

        // ============================================
        // MediaPipe Hand Tracking
        // ============================================
        const videoElement = document.getElementById('webcam');
        const handCanvasElement = document.getElementById('handCanvas');
        const handCtx = handCanvasElement.getContext('2d');
        const handCursor = document.getElementById('handCursor');

        // Landmark indices
        const WRIST = 0;
        const THUMB_TIP = 4;
        const INDEX_TIP = 8;
        const MIDDLE_TIP = 12;
        const RING_TIP = 16;
        const PINKY_TIP = 20;
        const INDEX_MCP = 5;

        function detectGesture(landmarks) {
            const thumbTip = landmarks[THUMB_TIP];
            const indexTip = landmarks[INDEX_TIP];
            const middleTip = landmarks[MIDDLE_TIP];
            const ringTip = landmarks[RING_TIP];
            const pinkyTip = landmarks[PINKY_TIP];
            const indexMcp = landmarks[INDEX_MCP];
            const wrist = landmarks[WRIST];

            // Calculate finger states (extended or not)
            const indexExtended = indexTip.y < indexMcp.y;
            const middleExtended = middleTip.y < landmarks[9].y;
            const ringExtended = ringTip.y < landmarks[13].y;
            const pinkyExtended = pinkyTip.y < landmarks[17].y;

            // Thumb extended (check x distance from palm)
            const thumbExtended = Math.abs(thumbTip.x - wrist.x) > 0.1;

            // Peace sign (V)
            if (indexExtended && middleExtended && !ringExtended && !pinkyExtended) {
                return 'peace';
            }

            // Point (only index)
            if (indexExtended && !middleExtended && !ringExtended && !pinkyExtended) {
                return 'point';
            }

            // Fist (all closed)
            if (!indexExtended && !middleExtended && !ringExtended && !pinkyExtended) {
                return 'fist';
            }

            // Open palm (all extended)
            if (indexExtended && middleExtended && ringExtended && pinkyExtended) {
                return 'palm';
            }

            return 'none';
        }

        function onResults(results) {
            // Update webcam status
            document.getElementById('webcamDot').classList.add('active');
            document.getElementById('webcamStatus').textContent = 'Tracking...';

            // Draw hands
            handCanvasElement.width = videoElement.videoWidth;
            handCanvasElement.height = videoElement.videoHeight;
            handCtx.clearRect(0, 0, handCanvasElement.width, handCanvasElement.height);

            state.handsDetected = { left: false, right: false };

            if (results.multiHandLandmarks && results.multiHandedness) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const landmarks = results.multiHandLandmarks[i];
                    const handedness = results.multiHandedness[i].label.toLowerCase();
                    // Mirror: MediaPipe "Right" appears on left side of mirrored video
                    const hand = handedness === 'right' ? 'left' : 'right';

                    state.handsDetected[hand] = true;

                    // Draw landmarks
                    drawConnectors(handCtx, landmarks, HAND_CONNECTIONS, { color: '#10B981', lineWidth: 2 });
                    drawLandmarks(handCtx, landmarks, { color: '#10B981', lineWidth: 1, radius: 3 });

                    // Detect gesture
                    const gesture = detectGesture(landmarks);
                    state.gestures[hand] = gesture;

                    // Get palm position (index finger base)
                    const palmPos = {
                        x: landmarks[INDEX_MCP].x,
                        y: landmarks[INDEX_MCP].y
                    };

                    // Calculate velocity
                    if (state.prevHandPositions[hand]) {
                        state.velocity[hand] = {
                            x: palmPos.x - state.prevHandPositions[hand].x,
                            y: palmPos.y - state.prevHandPositions[hand].y
                        };
                    }

                    state.prevHandPositions[hand] = state.handPositions[hand];
                    state.handPositions[hand] = palmPos;

                    // Update UI
                    updateHandUI(hand, gesture, palmPos);
                }
            }

            // Hide cursor if no hands
            if (!state.handsDetected.left && !state.handsDetected.right) {
                handCursor.classList.remove('visible');
                document.getElementById('leftHand').classList.remove('active');
                document.getElementById('rightHand').classList.remove('active');
                document.getElementById('leftAction').textContent = 'Not detected';
                document.getElementById('rightAction').textContent = 'Not detected';
                document.getElementById('leftGesture').textContent = '-';
                document.getElementById('rightGesture').textContent = '-';
            }

            // Process gestures
            processGestures();
        }

        function updateHandUI(hand, gesture, pos) {
            const handBox = document.getElementById(`${hand}Hand`);
            const gestureEl = document.getElementById(`${hand}Gesture`);
            const actionEl = document.getElementById(`${hand}Action`);

            handBox.classList.add('active');

            const gestureIcons = {
                'palm': 'ðŸ–ï¸',
                'fist': 'âœŠ',
                'point': 'â˜ï¸',
                'peace': 'âœŒï¸',
                'none': 'ðŸ¤š'
            };

            gestureEl.textContent = gestureIcons[gesture] || 'ðŸ¤š';

            if (state.mode === 'network') {
                const actions = {
                    'palm': 'Rotating camera',
                    'fist': 'Zooming',
                    'point': 'Selecting',
                    'peace': 'Reset view',
                    'none': 'Idle'
                };
                actionEl.textContent = actions[gesture] || 'Idle';
            } else {
                const actions = {
                    'palm': 'Steering',
                    'fist': 'Accelerating',
                    'point': 'Braking',
                    'peace': 'Reset',
                    'none': 'Idle'
                };
                actionEl.textContent = actions[gesture] || 'Idle';
            }

            // Update cursor position (use right hand for cursor)
            if (hand === 'right' && pos) {
                const screenX = (1 - pos.x) * window.innerWidth;
                const screenY = pos.y * window.innerHeight;
                handCursor.style.left = screenX + 'px';
                handCursor.style.top = screenY + 'px';
                handCursor.classList.add('visible');

                if (gesture === 'fist') {
                    handCursor.classList.add('grabbing');
                } else {
                    handCursor.classList.remove('grabbing');
                }
            }
        }

        function processGestures() {
            if (state.mode === 'network') {
                processNetworkGestures();
            } else {
                processDriveGestures();
            }
        }

        function processNetworkGestures() {
            // Left hand: Camera rotation with palm
            if (state.handsDetected.left && state.gestures.left === 'palm' && state.velocity.left) {
                state.cameraRotation.y += state.velocity.left.x * 3;
                state.cameraRotation.x += state.velocity.left.y * 2;
                state.cameraRotation.x = Math.max(-1, Math.min(1, state.cameraRotation.x));
            }

            // Right hand fist: Zoom
            if (state.handsDetected.right && state.gestures.right === 'fist' && state.velocity.right) {
                state.zoom -= state.velocity.right.y * 100;
                state.zoom = Math.max(25, Math.min(100, state.zoom));
            }

            // Peace sign: Reset
            if ((state.handsDetected.left && state.gestures.left === 'peace') ||
                (state.handsDetected.right && state.gestures.right === 'peace')) {
                state.cameraRotation = { x: 0, y: 0 };
                state.zoom = 50;
                showToast('View Reset');
            }

            // Update camera
            const theta = state.cameraRotation.y * Math.PI;
            const phi = (0.5 - state.cameraRotation.x * 0.3) * Math.PI;

            camera.position.x = state.zoom * Math.sin(phi) * Math.cos(theta);
            camera.position.y = state.zoom * Math.cos(phi) + 10;
            camera.position.z = state.zoom * Math.sin(phi) * Math.sin(theta);
            camera.lookAt(0, 5, 0);
        }

        function processDriveGestures() {
            // Left hand palm: Steering
            if (state.handsDetected.left && state.gestures.left === 'palm' && state.handPositions.left) {
                const steerAmount = (state.handPositions.left.x - 0.5) * 2;
                drive.steering = -steerAmount * drive.maxSteering;
            } else {
                drive.steering *= 0.9;
            }

            // Right hand fist: Accelerate
            if (state.handsDetected.right && state.gestures.right === 'fist') {
                drive.speed = Math.min(drive.speed + 0.05, drive.maxSpeed);
            } else if (state.handsDetected.right && state.gestures.right === 'point') {
                // Point: Brake
                drive.speed *= 0.9;
            } else {
                drive.speed *= 0.98;
                if (Math.abs(drive.speed) < 0.01) drive.speed = 0;
            }

            // Peace: Reset
            if ((state.handsDetected.left && state.gestures.left === 'peace') ||
                (state.handsDetected.right && state.gestures.right === 'peace')) {
                vehicleGroup.position.set(0, 0, 0);
                vehicleGroup.rotation.set(0, 0, 0);
                drive.speed = 0;
                drive.steering = 0;
                showToast('Position Reset');
            }

            // Apply driving
            vehicleGroup.translateZ(drive.speed);
            if (Math.abs(drive.speed) > 0.05) {
                vehicleGroup.rotateY(drive.steering * (drive.speed > 0 ? 1 : -1));
            }

            // Update speedometer
            document.getElementById('speedValue').textContent = Math.abs(drive.speed * 50).toFixed(0);

            // Follow camera
            const offset = new THREE.Vector3(0, 25, -60);
            const cameraTarget = offset.clone().applyMatrix4(vehicleGroup.matrixWorld);
            camera.position.lerp(cameraTarget, 0.08);

            const lookTarget = new THREE.Vector3(0, 5, 30);
            lookTarget.applyMatrix4(vehicleGroup.matrixWorld);
            camera.lookAt(lookTarget);

            // Update road position
            const vPos = vehicleGroup.position;
            roadGroup.position.z = Math.floor(vPos.z / 2000) * 2000;
            gridHelper.position.x = Math.floor(vPos.x / 200) * 200;
            gridHelper.position.z = Math.floor(vPos.z / 200) * 200;
        }

        // Initialize MediaPipe Hands
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // Initialize camera
        async function initCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480, facingMode: 'user' }
                });
                videoElement.srcObject = stream;
                await videoElement.play();

                const camera = new Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({ image: videoElement });
                    },
                    width: 640,
                    height: 480
                });
                camera.start();

                document.getElementById('loadingOverlay').classList.add('hidden');
            } catch (err) {
                console.error('Camera error:', err);
                document.getElementById('webcamStatus').textContent = 'Camera Error';
                document.getElementById('loadingOverlay').classList.add('hidden');
                showToast('Camera access denied - use keyboard controls');
            }
        }

        initCamera();

        // ============================================
        // Mode Switching
        // ============================================
        function setMode(mode) {
            state.mode = mode;

            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === mode);
            });

            document.getElementById('speedPanel').classList.toggle('visible', mode === 'drive');
            roadGroup.visible = mode === 'drive';

            if (mode === 'network') {
                vehicleGroup.position.set(0, 0, 0);
                vehicleGroup.rotation.set(0, 0, 0);
                drive.speed = 0;
                state.cameraRotation = { x: 0, y: 0 };
                state.zoom = 50;
            }

            showToast(`Switched to ${mode === 'network' ? 'Network' : 'Drive'} mode`);
        }

        // ============================================
        // Keyboard Fallback
        // ============================================
        const keys = { w: false, a: false, s: false, d: false, space: false };

        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (key in keys) keys[key] = true;
            if (key === ' ') { keys.space = true; e.preventDefault(); }
            if (key === '1') setMode('network');
            if (key === '2') setMode('drive');
        });

        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (key in keys) keys[key] = false;
            if (key === ' ') keys.space = false;
        });

        function processKeyboard() {
            if (state.mode === 'drive') {
                if (keys.w) drive.speed = Math.min(drive.speed + 0.04, drive.maxSpeed);
                if (keys.s) drive.speed = Math.max(drive.speed - 0.04, -drive.maxSpeed * 0.5);
                if (keys.space) drive.speed *= 0.9;
                if (!keys.w && !keys.s && !keys.space) {
                    drive.speed *= 0.98;
                    if (Math.abs(drive.speed) < 0.01) drive.speed = 0;
                }

                if (Math.abs(drive.speed) > 0.05) {
                    if (keys.a) drive.steering = Math.min(drive.steering + 0.002, drive.maxSteering);
                    else if (keys.d) drive.steering = Math.max(drive.steering - 0.002, -drive.maxSteering);
                    else drive.steering *= 0.85;
                }
            }
        }

        // ============================================
        // Animation Loop
        // ============================================
        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            processKeyboard();

            // Sensor pulse
            Object.values(sensors).forEach(s => {
                s.material.emissiveIntensity = 0.2 + Math.sin(time * 2) * 0.1;
            });

            renderer.render(scene, camera);
        }

        animate();

        // ============================================
        // Utilities
        // ============================================
        function showToast(msg) {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.classList.add('visible');
            setTimeout(() => toast.classList.remove('visible'), 2500);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
