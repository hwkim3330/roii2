<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ROii2 - Living Network</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #f0f4f8;
            --card: #ffffff;
            --text: #1a202c;
            --text-muted: #718096;
            --purple: #6C5CE7;
            --green: #10B981;
            --orange: #FF7675;
            --yellow: #FDCB6E;
            --blue: #3B82F6;
            --pink: #FAB1A0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
            height: 100vh;
        }

        #canvas3d {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }

        /* Header */
        .header {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 20px;
            z-index: 100;
        }

        .logo-box {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 24px;
            background: var(--card);
            border-radius: 50px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }

        .logo-box img { height: 28px; }
        .logo-box h1 {
            font-size: 20px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--purple), var(--blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .logo-box span {
            font-size: 13px;
            color: var(--text-muted);
            padding-left: 12px;
            border-left: 2px solid #eee;
        }

        /* Navigation */
        .nav-links {
            position: fixed;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 8px;
            z-index: 100;
        }

        .nav-link {
            padding: 10px 16px;
            background: var(--card);
            border-radius: 25px;
            color: var(--text);
            text-decoration: none;
            font-size: 13px;
            font-weight: 600;
            box-shadow: 0 2px 10px rgba(0,0,0,0.06);
            transition: all 0.2s;
        }

        .nav-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .nav-link i { margin-right: 6px; }

        /* Info Panel */
        .info-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 300px;
            background: var(--card);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            z-index: 100;
        }

        .panel-title {
            font-size: 12px;
            font-weight: 700;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .character-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
        }

        .character-box {
            text-align: center;
            padding: 12px 8px;
            background: #f8fafc;
            border-radius: 12px;
            transition: all 0.2s;
        }

        .character-box:hover {
            background: #f0f4f8;
            transform: scale(1.05);
        }

        .character-emoji {
            font-size: 28px;
            margin-bottom: 6px;
        }

        .character-name {
            font-size: 10px;
            font-weight: 600;
            color: var(--text-muted);
        }

        .character-count {
            font-size: 16px;
            font-weight: 700;
            color: var(--text);
        }

        /* Mood Indicator */
        .mood-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--card);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            z-index: 100;
            text-align: center;
        }

        .mood-face {
            font-size: 48px;
            margin-bottom: 8px;
            animation: bounce 2s ease-in-out infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        .mood-text {
            font-size: 14px;
            font-weight: 600;
            color: var(--text);
        }

        .mood-sub {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 4px;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            padding: 14px 28px;
            background: var(--purple);
            color: white;
            border-radius: 50px;
            font-weight: 600;
            font-size: 14px;
            opacity: 0;
            transition: all 0.3s;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(108, 92, 231, 0.4);
        }

        .toast.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Cursor */
        .custom-cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid var(--purple);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            transform: translate(-50%, -50%);
            transition: transform 0.1s, width 0.2s, height 0.2s;
            mix-blend-mode: difference;
        }

        .custom-cursor.hover {
            width: 50px;
            height: 50px;
            background: rgba(108, 92, 231, 0.2);
        }

        /* Floating animation keyframes */
        @keyframes float-slow {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-8px); }
        }

        @keyframes float-medium {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-6px); }
        }

        @keyframes float-fast {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-4px); }
        }
    </style>
</head>
<body>
    <canvas id="canvas3d"></canvas>

    <div class="nav-links">
        <a href="index.html" class="nav-link"><i class="fas fa-project-diagram"></i> Network</a>
        <a href="drive.html" class="nav-link"><i class="fas fa-car"></i> Drive</a>
        <a href="fault.html" class="nav-link"><i class="fas fa-bolt"></i> Fault</a>
    </div>

    <div class="header">
        <div class="logo-box">
            <img src="keti.png" alt="KETI">
            <h1>ROii2</h1>
            <span>Living Network</span>
        </div>
    </div>

    <div class="info-panel">
        <div class="panel-title"><i class="fas fa-heart"></i> Network Characters</div>
        <div class="character-grid">
            <div class="character-box" style="background: rgba(108,92,231,0.1);">
                <div class="character-emoji">ðŸŸ£</div>
                <div class="character-name">LiDAR</div>
                <div class="character-count">4</div>
            </div>
            <div class="character-box" style="background: rgba(13,202,240,0.1);">
                <div class="character-emoji">ðŸ”µ</div>
                <div class="character-name">Camera</div>
                <div class="character-count">8</div>
            </div>
            <div class="character-box" style="background: rgba(253,203,110,0.1);">
                <div class="character-emoji">ðŸŸ¡</div>
                <div class="character-name">Radar</div>
                <div class="character-count">5</div>
            </div>
            <div class="character-box" style="background: rgba(59,130,246,0.1);">
                <div class="character-emoji">ðŸ”²</div>
                <div class="character-name">Zone</div>
                <div class="character-count">3</div>
            </div>
        </div>
    </div>

    <div class="mood-panel">
        <div class="mood-face" id="moodFace">ðŸ˜Š</div>
        <div class="mood-text" id="moodText">All Systems Happy!</div>
        <div class="mood-sub" id="moodSub">17 sensors watching you</div>
    </div>

    <div class="custom-cursor" id="cursor"></div>
    <div class="toast" id="toast"></div>

    <script src="libs/three.min.js"></script>
    <script src="libs/OrbitControls.js"></script>
    <script src="libs/GLTFLoader.js"></script>

    <script>
        // ============================================
        // State
        // ============================================
        const state = {
            mousePos: { x: 0, y: 0 },
            mouse3D: new THREE.Vector3(),
            hoveredSensor: null,
            blinkingEntities: new Set()
        };

        // ============================================
        // Three.js Setup
        // ============================================
        const canvas = document.getElementById('canvas3d');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f4f8);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(50, 40, 50);

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 30;
        controls.maxDistance = 100;
        controls.target.set(0, 5, 0);

        // Lighting - Soft and friendly
        scene.add(new THREE.AmbientLight(0xffffff, 0.7));

        const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
        sunLight.position.set(40, 60, 40);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);

        const fillLight = new THREE.DirectionalLight(0xffeedd, 0.3);
        fillLight.position.set(-30, 30, -30);
        scene.add(fillLight);

        // Ground - Soft gradient feel
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(200, 200),
            new THREE.MeshStandardMaterial({
                color: 0xe8eef4,
                roughness: 0.9,
                metalness: 0
            })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Subtle grid
        const grid = new THREE.GridHelper(100, 40, 0xd0d8e0, 0xe0e8f0);
        grid.position.y = 0.01;
        scene.add(grid);

        // ============================================
        // Sensor Configuration with Personalities
        // ============================================
        const sensorConfig = {
            'LiDAR-FL': { pos: [-8.5, 10, 16.2], type: 'lidar', color: 0x6C5CE7, personality: 'curious' },
            'LiDAR-FR': { pos: [8.5, 10, 16.2], type: 'lidar', color: 0x6C5CE7, personality: 'alert' },
            'LiDAR-FC': { pos: [0, 5.5, 18.5], type: 'lidar', color: 0x6C5CE7, personality: 'focused' },
            'LiDAR-RC': { pos: [0, 5.5, -18.5], type: 'lidar', color: 0x6C5CE7, personality: 'sleepy' },
            'Cam-FC': { pos: [0, 10.5, 18.5], type: 'camera', color: 0x0dcaf0, personality: 'cheerful' },
            'Cam-FL': { pos: [0.6, 10.5, 18.5], type: 'camera', color: 0x0dcaf0, personality: 'shy' },
            'Cam-FR': { pos: [-0.6, 10.5, 18.5], type: 'camera', color: 0x0dcaf0, personality: 'excited' },
            'Cam-SL1': { pos: [-8.5, 11, 16.5], type: 'camera', color: 0x0dcaf0, personality: 'watchful' },
            'Cam-SR1': { pos: [8.5, 11, 16.5], type: 'camera', color: 0x0dcaf0, personality: 'playful' },
            'Cam-SL2': { pos: [-8.5, 11, 15.9], type: 'camera', color: 0x0dcaf0, personality: 'calm' },
            'Cam-SR2': { pos: [8.5, 11, 15.9], type: 'camera', color: 0x0dcaf0, personality: 'happy' },
            'Cam-RC': { pos: [0, 9, -18.5], type: 'camera', color: 0x0dcaf0, personality: 'dreamy' },
            'Radar-FC': { pos: [0, 7, 18.5], type: 'radar', color: 0xFDCB6E, personality: 'energetic' },
            'Radar-FL': { pos: [-7, 6.5, 17.5], type: 'radar', color: 0xFDCB6E, personality: 'brave' },
            'Radar-FR': { pos: [7, 6.5, 17.5], type: 'radar', color: 0xFDCB6E, personality: 'bold' },
            'Radar-RL': { pos: [-7, 6.5, -18], type: 'radar', color: 0xFDCB6E, personality: 'quiet' },
            'Radar-RR': { pos: [7, 6.5, -18], type: 'radar', color: 0xFDCB6E, personality: 'wise' }
        };

        const zoneConfig = {
            'ACU_IT': { pos: [0, 4, 0], color: 0xFF7675, size: [4, 2.5, 3], personality: 'boss' },
            'Front-L-9692': { pos: [-3.5, 4, 10], color: 0x3B82F6, size: [2.5, 1.5, 2], personality: 'worker' },
            'Front-R-9692': { pos: [3.5, 4, 10], color: 0x3B82F6, size: [2.5, 1.5, 2], personality: 'helper' },
            'Rear-9692': { pos: [0, 4, -10], color: 0x3B82F6, size: [2.5, 1.5, 2], personality: 'guard' }
        };

        const sensors = {};
        const zones = {};
        const allCharacters = [];
        let vehicleGroup = new THREE.Group();
        scene.add(vehicleGroup);

        // ============================================
        // Create Living Sensor Characters
        // ============================================
        function createEyeCharacter(name, config, isZone = false) {
            const group = new THREE.Group();
            group.position.set(...config.pos);
            group.name = name;
            group.userData = {
                ...config,
                isZone,
                blinking: false,
                blinkPhase: 0,
                floatPhase: Math.random() * Math.PI * 2,
                baseY: config.pos[1]
            };

            // Body
            let bodyGeo, bodySize;
            if (isZone) {
                bodyGeo = new THREE.BoxGeometry(...config.size);
                bodySize = Math.max(...config.size);
            } else if (config.type === 'lidar') {
                bodyGeo = new THREE.SphereGeometry(1, 32, 32);
                bodySize = 2;
            } else if (config.type === 'camera') {
                bodyGeo = new THREE.CylinderGeometry(0.6, 0.8, 1.2, 32);
                bodySize = 1.5;
            } else {
                bodyGeo = new THREE.ConeGeometry(0.7, 1.4, 32);
                bodySize = 1.4;
            }

            const bodyMat = new THREE.MeshStandardMaterial({
                color: config.color,
                roughness: 0.4,
                metalness: 0.2
            });

            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.castShadow = true;
            group.add(body);

            // Eyes
            const eyeSize = isZone ? 0.4 : 0.25;
            const eyeSpacing = isZone ? 0.7 : 0.4;
            const eyeHeight = isZone ? config.size[1] * 0.2 : bodySize * 0.15;

            // Left Eye
            const leftEyeGroup = createEye(eyeSize);
            leftEyeGroup.position.set(-eyeSpacing, eyeHeight, isZone ? config.size[2] / 2 + 0.01 : bodySize * 0.4);
            group.add(leftEyeGroup);

            // Right Eye
            const rightEyeGroup = createEye(eyeSize);
            rightEyeGroup.position.set(eyeSpacing, eyeHeight, isZone ? config.size[2] / 2 + 0.01 : bodySize * 0.4);
            group.add(rightEyeGroup);

            group.userData.leftEye = leftEyeGroup;
            group.userData.rightEye = rightEyeGroup;
            group.userData.eyeSize = eyeSize;

            // Mouth (small smile)
            if (!isZone) {
                const smileGeo = new THREE.TorusGeometry(eyeSize * 0.6, eyeSize * 0.1, 8, 16, Math.PI);
                const smileMat = new THREE.MeshBasicMaterial({ color: 0x333333 });
                const smile = new THREE.Mesh(smileGeo, smileMat);
                smile.position.set(0, eyeHeight - eyeSize * 1.5, bodySize * 0.42);
                smile.rotation.x = Math.PI;
                smile.rotation.z = Math.PI;
                group.add(smile);
                group.userData.mouth = smile;
            }

            // Add blush cheeks for cute effect
            if (config.personality === 'shy' || config.personality === 'cheerful') {
                const blushGeo = new THREE.CircleGeometry(eyeSize * 0.4, 16);
                const blushMat = new THREE.MeshBasicMaterial({
                    color: 0xFFB6C1,
                    transparent: true,
                    opacity: 0.5,
                    side: THREE.DoubleSide
                });

                const leftBlush = new THREE.Mesh(blushGeo, blushMat);
                leftBlush.position.set(-eyeSpacing - eyeSize * 0.3, eyeHeight - eyeSize * 0.5, bodySize * 0.43);
                group.add(leftBlush);

                const rightBlush = new THREE.Mesh(blushGeo, blushMat);
                rightBlush.position.set(eyeSpacing + eyeSize * 0.3, eyeHeight - eyeSize * 0.5, bodySize * 0.43);
                group.add(rightBlush);
            }

            vehicleGroup.add(group);
            allCharacters.push(group);

            if (isZone) {
                zones[name] = group;
            } else {
                sensors[name] = group;
            }

            return group;
        }

        function createEye(size) {
            const group = new THREE.Group();

            // White of eye
            const whiteGeo = new THREE.SphereGeometry(size, 32, 32);
            const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
            const white = new THREE.Mesh(whiteGeo, whiteMat);
            group.add(white);

            // Pupil
            const pupilGeo = new THREE.SphereGeometry(size * 0.5, 16, 16);
            const pupilMat = new THREE.MeshBasicMaterial({ color: 0x1F2937 });
            const pupil = new THREE.Mesh(pupilGeo, pupilMat);
            pupil.position.z = size * 0.5;
            group.add(pupil);

            // Highlight/Sparkle
            const highlightGeo = new THREE.SphereGeometry(size * 0.15, 8, 8);
            const highlightMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const highlight = new THREE.Mesh(highlightGeo, highlightMat);
            highlight.position.set(size * 0.2, size * 0.2, size * 0.75);
            group.add(highlight);

            // Eyelid for blinking
            const lidGeo = new THREE.SphereGeometry(size * 1.1, 32, 16, 0, Math.PI * 2, 0, Math.PI * 0.5);
            const lidMat = new THREE.MeshStandardMaterial({
                color: 0x333333,
                side: THREE.DoubleSide
            });
            const lid = new THREE.Mesh(lidGeo, lidMat);
            lid.rotation.x = Math.PI;
            lid.position.y = size * 0.3;
            lid.scale.y = 0; // Hidden initially
            group.add(lid);

            group.userData = { pupil, lid, maxMove: size * 0.3 };

            return group;
        }

        // ============================================
        // Load Vehicle Model
        // ============================================
        const loader = new THREE.GLTFLoader();
        loader.load('roii.glb', (gltf) => {
            const model = gltf.scene;
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());

            const targetSize = 40;
            const scale = targetSize / Math.max(size.x, size.y, size.z);
            model.scale.set(scale, scale, scale);

            const scaledHeight = size.y * scale;
            model.position.set(-center.x * scale, -center.y * scale + scaledHeight * 0.5 + 0.5, -center.z * scale);

            model.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.material.transparent = true;
                    child.material.opacity = 0.6;
                    child.material.side = THREE.DoubleSide;
                    if (child.material.color) {
                        child.material.color.multiplyScalar(1.3);
                    }
                    child.castShadow = true;
                }
            });

            vehicleGroup.add(model);

            // Create characters after model loads
            Object.entries(sensorConfig).forEach(([name, cfg]) => {
                createEyeCharacter(name, cfg, false);
            });

            Object.entries(zoneConfig).forEach(([name, cfg]) => {
                createEyeCharacter(name, cfg, true);
            });

            // Create network connections
            createNetworkConnections();

            showToast('Welcome! The network is alive! ðŸ‘€');
        });

        // ============================================
        // Network Connections
        // ============================================
        function createNetworkConnections() {
            const connections = [
                ['ACU_IT', 'Front-L-9692', 0xffd700],
                ['ACU_IT', 'Front-R-9692', 0xffd700],
                ['ACU_IT', 'Rear-9692', 0xffd700],
                ['Front-L-9692', 'Front-R-9692', 0x10b981]
            ];

            connections.forEach(([from, to, color]) => {
                const fromPos = new THREE.Vector3(...zoneConfig[from].pos);
                const toPos = new THREE.Vector3(...zoneConfig[to].pos);

                const curve = new THREE.CatmullRomCurve3([fromPos, toPos]);
                const geo = new THREE.TubeGeometry(curve, 20, 0.1, 8, false);
                const mat = new THREE.MeshBasicMaterial({
                    color,
                    transparent: true,
                    opacity: 0.6
                });
                const tube = new THREE.Mesh(geo, mat);
                vehicleGroup.add(tube);
            });
        }

        // ============================================
        // Eye Tracking Logic
        // ============================================
        function updateEyeTracking() {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2(
                (state.mousePos.x / window.innerWidth) * 2 - 1,
                -(state.mousePos.y / window.innerHeight) * 2 + 1
            );

            raycaster.setFromCamera(mouse, camera);

            // Get a point in 3D space where mouse is pointing
            const planeNormal = new THREE.Vector3(0, 0, 1).applyQuaternion(camera.quaternion);
            const plane = new THREE.Plane(planeNormal, 0);
            raycaster.ray.intersectPlane(plane, state.mouse3D);

            allCharacters.forEach(char => {
                if (!char.userData.leftEye || !char.userData.rightEye) return;
                if (char.userData.blinking) return;

                const worldPos = new THREE.Vector3();
                char.getWorldPosition(worldPos);

                // Direction to mouse
                const direction = state.mouse3D.clone().sub(worldPos).normalize();

                // Update both eyes
                [char.userData.leftEye, char.userData.rightEye].forEach(eye => {
                    const pupil = eye.userData.pupil;
                    const maxMove = eye.userData.maxMove;

                    // Calculate local direction
                    const localDir = direction.clone();
                    char.worldToLocal(localDir);

                    // Move pupil
                    const px = Math.max(-maxMove, Math.min(maxMove, localDir.x * maxMove * 2));
                    const py = Math.max(-maxMove, Math.min(maxMove, localDir.y * maxMove * 2));

                    pupil.position.x = px;
                    pupil.position.y = py;
                });
            });
        }

        // ============================================
        // Blinking Logic
        // ============================================
        function triggerRandomBlink() {
            if (allCharacters.length === 0) return;

            const randomChar = allCharacters[Math.floor(Math.random() * allCharacters.length)];
            if (randomChar.userData.blinking) return;

            randomChar.userData.blinking = true;
            randomChar.userData.blinkPhase = 0;

            // Close eyes
            [randomChar.userData.leftEye, randomChar.userData.rightEye].forEach(eye => {
                if (eye && eye.userData.lid) {
                    eye.userData.lid.scale.y = 1;
                }
            });

            // Open eyes after short delay
            setTimeout(() => {
                [randomChar.userData.leftEye, randomChar.userData.rightEye].forEach(eye => {
                    if (eye && eye.userData.lid) {
                        eye.userData.lid.scale.y = 0;
                    }
                });
                randomChar.userData.blinking = false;
            }, 150);
        }

        // Random blinking interval
        setInterval(triggerRandomBlink, 800);

        // ============================================
        // Floating Animation
        // ============================================
        function updateFloating(time) {
            allCharacters.forEach(char => {
                const baseY = char.userData.baseY;
                const phase = char.userData.floatPhase;
                const floatAmount = char.userData.isZone ? 0.15 : 0.25;

                char.position.y = baseY + Math.sin(time * 2 + phase) * floatAmount;
            });
        }

        // ============================================
        // Mouse Events
        // ============================================
        const cursor = document.getElementById('cursor');

        window.addEventListener('mousemove', (e) => {
            state.mousePos.x = e.clientX;
            state.mousePos.y = e.clientY;

            cursor.style.left = e.clientX + 'px';
            cursor.style.top = e.clientY + 'px';
        });

        // Raycaster for hover detection
        const hoverRaycaster = new THREE.Raycaster();

        function checkHover() {
            const mouse = new THREE.Vector2(
                (state.mousePos.x / window.innerWidth) * 2 - 1,
                -(state.mousePos.y / window.innerHeight) * 2 + 1
            );

            hoverRaycaster.setFromCamera(mouse, camera);
            const intersects = hoverRaycaster.intersectObjects(vehicleGroup.children, true);

            let hoveredChar = null;
            if (intersects.length > 0) {
                let obj = intersects[0].object;
                while (obj.parent && !allCharacters.includes(obj)) {
                    obj = obj.parent;
                }
                if (allCharacters.includes(obj)) {
                    hoveredChar = obj;
                }
            }

            if (hoveredChar !== state.hoveredSensor) {
                state.hoveredSensor = hoveredChar;

                if (hoveredChar) {
                    cursor.classList.add('hover');
                    updateMood(hoveredChar.name, hoveredChar.userData.personality);
                } else {
                    cursor.classList.remove('hover');
                    resetMood();
                }
            }
        }

        // ============================================
        // Mood Panel
        // ============================================
        const moodEmojis = {
            'curious': 'ðŸ¤”',
            'alert': 'ðŸ˜®',
            'focused': 'ðŸŽ¯',
            'sleepy': 'ðŸ˜´',
            'cheerful': 'ðŸ˜Š',
            'shy': 'ðŸ˜³',
            'excited': 'ðŸ¤©',
            'watchful': 'ðŸ‘€',
            'playful': 'ðŸ˜œ',
            'calm': 'ðŸ˜Œ',
            'happy': 'ðŸ˜„',
            'dreamy': 'ðŸŒ™',
            'energetic': 'âš¡',
            'brave': 'ðŸ’ª',
            'bold': 'ðŸ˜Ž',
            'quiet': 'ðŸ¤«',
            'wise': 'ðŸ¦‰',
            'boss': 'ðŸ‘‘',
            'worker': 'ðŸ”§',
            'helper': 'ðŸ¤',
            'guard': 'ðŸ›¡ï¸'
        };

        const moodTexts = {
            'curious': 'Hmm, what\'s that?',
            'alert': 'I see everything!',
            'focused': 'Locked on target',
            'sleepy': 'zzz... watching...',
            'cheerful': 'Hello there!',
            'shy': '*blushes*',
            'excited': 'Woohoo!',
            'watchful': 'Always vigilant',
            'playful': 'Catch me if you can!',
            'calm': 'All is well',
            'happy': 'Great to see you!',
            'dreamy': 'Lost in thoughts...',
            'energetic': 'Let\'s go!',
            'brave': 'No fear!',
            'bold': 'I got this',
            'quiet': 'Shh...',
            'wise': 'I know things',
            'boss': 'I\'m in charge',
            'worker': 'On duty!',
            'helper': 'How can I help?',
            'guard': 'None shall pass!'
        };

        function updateMood(name, personality) {
            document.getElementById('moodFace').textContent = moodEmojis[personality] || 'ðŸ˜Š';
            document.getElementById('moodText').textContent = moodTexts[personality] || 'Hello!';
            document.getElementById('moodSub').textContent = name;
        }

        function resetMood() {
            document.getElementById('moodFace').textContent = 'ðŸ˜Š';
            document.getElementById('moodText').textContent = 'All Systems Happy!';
            document.getElementById('moodSub').textContent = '17 sensors watching you';
        }

        // ============================================
        // Animation Loop
        // ============================================
        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            updateEyeTracking();
            updateFloating(time);
            checkHover();

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // ============================================
        // Utilities
        // ============================================
        function showToast(msg) {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.classList.add('visible');
            setTimeout(() => toast.classList.remove('visible'), 3000);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
