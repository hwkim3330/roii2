<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ROii2 - TSN Data Runner</title>
    <script src="libs/three.min.js"></script>
    <script src="libs/GLTFLoader.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Orbitron', sans-serif;
            background: #000;
            overflow: hidden;
            color: white;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
        #game { width: 100vw; height: 100vh; }

        /* Screen effects */
        .screen-flash {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            opacity: 0;
            z-index: 50;
        }
        .screen-flash.damage {
            background: radial-gradient(circle, transparent 30%, rgba(255,0,50,0.6) 100%);
            animation: flashDamage 0.3s ease-out;
        }
        .screen-flash.collect {
            background: radial-gradient(circle, rgba(0,255,255,0.3) 0%, transparent 70%);
            animation: flashCollect 0.2s ease-out;
        }
        .screen-flash.powerup {
            background: radial-gradient(circle, rgba(0,255,0,0.4) 0%, transparent 70%);
            animation: flashPowerup 0.4s ease-out;
        }
        @keyframes flashDamage { 0% { opacity: 1; } 100% { opacity: 0; } }
        @keyframes flashCollect { 0% { opacity: 1; } 100% { opacity: 0; } }
        @keyframes flashPowerup { 0% { opacity: 1; } 100% { opacity: 0; } }

        /* HUD */
        .hud {
            position: absolute;
            top: 0; left: 0; right: 0;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 10;
        }
        .hud-left, .hud-right { display: flex; flex-direction: column; gap: 10px; }
        .hud-center { text-align: center; }

        .score-display {
            font-size: 32px;
            font-weight: 900;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
            letter-spacing: 2px;
        }
        .score-label { font-size: 10px; color: #00aaaa; letter-spacing: 3px; }

        .stat-box {
            background: rgba(0,20,40,0.9);
            border: 1px solid #00ffff;
            padding: 8px 15px;
            border-radius: 8px;
            min-width: 100px;
        }
        .stat-label { font-size: 9px; color: #00aaaa; letter-spacing: 1px; }
        .stat-value { font-size: 18px; color: #00ffff; }

        /* Combo display */
        .combo-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 20;
        }
        .combo-text {
            font-size: 48px;
            font-weight: 900;
            opacity: 0;
            transform: scale(0.5);
            text-shadow: 0 0 30px currentColor;
        }
        .combo-text.show {
            animation: comboPopup 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }
        @keyframes comboPopup {
            0% { opacity: 0; transform: scale(0.5) translateY(20px); }
            50% { opacity: 1; transform: scale(1.2) translateY(-10px); }
            100% { opacity: 0; transform: scale(1) translateY(-30px); }
        }

        /* Streak counter */
        .streak-display {
            position: absolute;
            top: 100px;
            right: 20px;
            text-align: right;
            pointer-events: none;
        }
        .streak-count {
            font-size: 36px;
            font-weight: 900;
            color: #ffaa00;
            text-shadow: 0 0 20px #ffaa00;
        }
        .streak-label { font-size: 10px; color: #aa7700; }
        .streak-multiplier {
            font-size: 14px;
            color: #ff6600;
            margin-top: 5px;
        }

        /* Power-up indicators */
        .powerup-bar {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            pointer-events: none;
        }
        .powerup-slot {
            width: 50px;
            height: 50px;
            background: rgba(0,20,40,0.8);
            border: 2px solid #333;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            opacity: 0.3;
            transition: all 0.3s;
            position: relative;
        }
        .powerup-slot.active {
            opacity: 1;
            border-color: #00ff00;
            box-shadow: 0 0 20px rgba(0,255,0,0.5);
        }
        .powerup-timer {
            position: absolute;
            bottom: -5px;
            left: 0; right: 0;
            height: 4px;
            background: #00ff00;
            border-radius: 2px;
            transform-origin: left;
        }

        /* Health bar */
        .health-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            pointer-events: none;
        }
        .health-bar {
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00ffaa);
            transition: width 0.3s, background 0.3s;
            border-radius: 4px;
        }
        .health-fill.warning { background: linear-gradient(90deg, #ffaa00, #ff6600); }
        .health-fill.danger { background: linear-gradient(90deg, #ff0044, #ff0000); }
        .health-label {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #666;
            margin-top: 5px;
        }

        /* Lane indicators */
        .lane-indicators {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 30px;
            pointer-events: none;
        }
        .lane-dot {
            width: 12px;
            height: 12px;
            border: 2px solid #00ffff;
            border-radius: 50%;
            opacity: 0.3;
            transition: all 0.2s;
        }
        .lane-dot.active {
            opacity: 1;
            background: #00ffff;
            box-shadow: 0 0 15px #00ffff;
        }

        /* Touch zones */
        .touch-zone {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 25%;
            z-index: 5;
            display: none;
        }
        .touch-zone.left { left: 0; }
        .touch-zone.right { right: 0; }
        @media (pointer: coarse) {
            .touch-zone { display: block; }
        }

        /* Menu screens */
        .menu-screen, .game-over {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,5,15,0.97);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        .menu-screen h1 {
            font-size: 48px;
            color: #00ffff;
            text-shadow: 0 0 40px #00ffff, 0 0 80px #00ffff;
            margin-bottom: 10px;
            letter-spacing: 5px;
        }
        .subtitle {
            font-size: 14px;
            color: #00aaaa;
            margin-bottom: 40px;
            letter-spacing: 3px;
        }
        .game-over h1 {
            color: #ff0054;
            text-shadow: 0 0 40px #ff0054;
        }

        .high-score {
            font-size: 12px;
            color: #ffaa00;
            margin-bottom: 30px;
        }
        .high-score span { font-size: 20px; }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 30px 0;
        }
        .stat-item {
            text-align: center;
            padding: 15px 25px;
            background: rgba(0,255,255,0.05);
            border: 1px solid rgba(0,255,255,0.3);
            border-radius: 10px;
        }
        .stat-item .value { font-size: 28px; color: #00ffff; }
        .stat-item .label { font-size: 10px; color: #00aaaa; margin-top: 5px; }

        .btn {
            padding: 15px 50px;
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            font-weight: bold;
            background: transparent;
            border: 2px solid #00ffff;
            color: #00ffff;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
            border-radius: 5px;
            letter-spacing: 3px;
            text-transform: uppercase;
        }
        .btn:hover, .btn:active {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 40px #00ffff;
            transform: scale(1.05);
        }

        .controls-info {
            margin-top: 40px;
            font-size: 11px;
            color: #444;
            text-align: center;
            line-height: 2;
        }
        .controls-info span { color: #00ffff; }

        /* Sound toggle */
        .sound-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(0,20,40,0.8);
            border: 1px solid #00ffff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            z-index: 101;
            transition: all 0.3s;
        }
        .sound-toggle:hover { background: rgba(0,255,255,0.2); }
        .sound-toggle.muted { opacity: 0.5; }

        /* Loading */
        .loading {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid #111;
            border-top-color: #00ffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .loading-text { margin-top: 20px; color: #00ffff; font-size: 14px; }

        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        <div class="loading-spinner"></div>
        <div class="loading-text">INITIALIZING TSN NETWORK...</div>
    </div>

    <div id="game"></div>
    <div class="screen-flash" id="screenFlash"></div>

    <!-- Touch zones for mobile -->
    <div class="touch-zone left" id="touchLeft"></div>
    <div class="touch-zone right" id="touchRight"></div>

    <!-- HUD -->
    <div class="hud hidden" id="hud">
        <div class="hud-left">
            <div class="stat-box">
                <div class="stat-label">LEVEL</div>
                <div class="stat-value" id="level">1</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">DISTANCE</div>
                <div class="stat-value" id="distance">0m</div>
            </div>
        </div>
        <div class="hud-center">
            <div class="score-label">THROUGHPUT</div>
            <div class="score-display" id="score">0</div>
        </div>
        <div class="hud-right">
            <div class="stat-box">
                <div class="stat-label">SPEED</div>
                <div class="stat-value" id="speed">0 Gbps</div>
            </div>
        </div>
    </div>

    <!-- Streak display -->
    <div class="streak-display hidden" id="streakDisplay">
        <div class="streak-count" id="streakCount">0</div>
        <div class="streak-label">STREAK</div>
        <div class="streak-multiplier" id="multiplier">x1.0</div>
    </div>

    <!-- Combo popup -->
    <div class="combo-container" id="comboContainer">
        <div class="combo-text" id="comboText"></div>
    </div>

    <!-- Power-up bar -->
    <div class="powerup-bar hidden" id="powerupBar">
        <div class="powerup-slot" id="powerShield" title="Shield">üõ°Ô∏è</div>
        <div class="powerup-slot" id="powerMagnet" title="Magnet">üß≤</div>
        <div class="powerup-slot" id="powerDouble" title="2x Score">‚ú®</div>
    </div>

    <!-- Lane indicators -->
    <div class="lane-indicators hidden" id="laneIndicators">
        <div class="lane-dot" id="lane-1"></div>
        <div class="lane-dot active" id="lane0"></div>
        <div class="lane-dot" id="lane1"></div>
    </div>

    <!-- Health bar -->
    <div class="health-container hidden" id="healthContainer">
        <div class="health-bar">
            <div class="health-fill" id="healthFill" style="width: 100%"></div>
        </div>
        <div class="health-label">
            <span>NETWORK HEALTH</span>
            <span id="healthPercent">100%</span>
        </div>
    </div>

    <!-- Sound toggle -->
    <div class="sound-toggle" id="soundToggle">üîä</div>

    <!-- Menu screen -->
    <div class="menu-screen" id="menuScreen">
        <h1>TSN RUNNER</h1>
        <div class="subtitle">COLLECT DATA ‚Ä¢ AVOID FAULTS ‚Ä¢ SURVIVE</div>
        <img src="keti.png" style="width:70px;margin:20px;opacity:0.7;">
        <div class="high-score" id="highScoreDisplay">HIGH SCORE: <span>0</span></div>
        <button class="btn" onclick="startGame()">START</button>
        <div class="controls-info">
            <span>‚Üê</span> <span>‚Üí</span> or <span>A</span> <span>D</span> : Switch Lanes<br>
            <span>SPACE</span> or <span>‚Üë</span> : Jump (Double Jump!)<br>
            <span>‚Üì</span> or <span>S</span> : Slide<br>
            <span>Mobile</span>: Tap sides to move, Swipe up/down
        </div>
    </div>

    <!-- Game over screen -->
    <div class="game-over hidden" id="gameOver">
        <h1>NETWORK FAILURE</h1>
        <div class="subtitle">CONNECTION TERMINATED</div>
        <div class="stats-grid">
            <div class="stat-item">
                <div class="value" id="finalScore">0</div>
                <div class="label">THROUGHPUT</div>
            </div>
            <div class="stat-item">
                <div class="value" id="finalDistance">0m</div>
                <div class="label">DISTANCE</div>
            </div>
            <div class="stat-item">
                <div class="value" id="finalStreak">0</div>
                <div class="label">BEST STREAK</div>
            </div>
            <div class="stat-item">
                <div class="value" id="finalLevel">1</div>
                <div class="label">LEVEL</div>
            </div>
        </div>
        <div id="newHighScore" class="hidden" style="color:#ffaa00;font-size:18px;margin:10px;">NEW HIGH SCORE!</div>
        <button class="btn" onclick="startGame()">RETRY</button>
        <button class="btn" onclick="showMenu()" style="border-color:#666;color:#666;">MENU</button>
    </div>

    <script>
    // ==================== AUDIO ENGINE ====================
    class AudioEngine {
        constructor() {
            this.ctx = null;
            this.enabled = true;
            this.masterGain = null;
            this.sounds = {};
        }

        init() {
            if (this.ctx) return;
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.masterGain = this.ctx.createGain();
            this.masterGain.connect(this.ctx.destination);
            this.masterGain.gain.value = 0.3;
        }

        resume() {
            if (this.ctx && this.ctx.state === 'suspended') {
                this.ctx.resume();
            }
        }

        toggle() {
            this.enabled = !this.enabled;
            if (this.masterGain) {
                this.masterGain.gain.value = this.enabled ? 0.3 : 0;
            }
            return this.enabled;
        }

        // Synthesize sounds
        playJump() {
            if (!this.ctx || !this.enabled) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.connect(gain);
            gain.connect(this.masterGain);
            osc.type = 'sine';
            osc.frequency.setValueAtTime(300, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(600, this.ctx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.15);
        }

        playDoubleJump() {
            if (!this.ctx || !this.enabled) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.connect(gain);
            gain.connect(this.masterGain);
            osc.type = 'sine';
            osc.frequency.setValueAtTime(500, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(1000, this.ctx.currentTime + 0.12);
            gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.15);
        }

        playSlide() {
            if (!this.ctx || !this.enabled) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.connect(gain);
            gain.connect(this.masterGain);
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(200, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.15, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.1);
        }

        playCollect(type) {
            if (!this.ctx || !this.enabled) return;
            const freqs = { lidar: 800, camera: 600, radar: 700 };
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.connect(gain);
            gain.connect(this.masterGain);
            osc.type = 'sine';
            const baseFreq = freqs[type] || 600;
            osc.frequency.setValueAtTime(baseFreq, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(baseFreq * 1.5, this.ctx.currentTime + 0.05);
            osc.frequency.exponentialRampToValueAtTime(baseFreq * 2, this.ctx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.25, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.15);
        }

        playCombo(level) {
            if (!this.ctx || !this.enabled) return;
            const baseFreq = 400 + level * 50;
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    osc.type = 'sine';
                    osc.frequency.value = baseFreq + i * 200;
                    gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.1);
                }, i * 50);
            }
        }

        playDamage() {
            if (!this.ctx || !this.enabled) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.connect(gain);
            gain.connect(this.masterGain);
            osc.type = 'square';
            osc.frequency.setValueAtTime(150, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.2);
            gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.25);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.25);
        }

        playPowerup() {
            if (!this.ctx || !this.enabled) return;
            const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
            notes.forEach((freq, i) => {
                setTimeout(() => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.15);
                }, i * 80);
            });
        }

        playGameOver() {
            if (!this.ctx || !this.enabled) return;
            const notes = [400, 350, 300, 200];
            notes.forEach((freq, i) => {
                setTimeout(() => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    osc.type = 'sawtooth';
                    osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.3);
                }, i * 150);
            });
        }

        playLevelUp() {
            if (!this.ctx || !this.enabled) return;
            const notes = [523, 659, 784, 1047, 1319];
            notes.forEach((freq, i) => {
                setTimeout(() => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0.25, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.2);
                }, i * 100);
            });
        }
    }

    const audio = new AudioEngine();

    // ==================== GAME CONFIG ====================
    const CONFIG = {
        LANE_WIDTH: 4,
        LANE_COUNT: 3,
        SPAWN_DISTANCE: 100,
        BASE_SPEED: 30,
        MAX_SPEED: 100,
        GRAVITY: 70,
        JUMP_FORCE: 22,
        DOUBLE_JUMP_FORCE: 18,
        SLIDE_DURATION: 0.5,
        LEVEL_DISTANCE: [500, 1200, 2000, 3000, 4500, 6500, 9000, 12000],
        POWERUP_DURATION: 8,
    };

    const PACKET_TYPES = ['lidar', 'camera', 'radar'];
    const PACKET_COLORS = { lidar: 0x9966ff, camera: 0x4488ff, radar: 0xffaa00 };
    const PACKET_VALUES = { lidar: 100, camera: 50, radar: 75 };

    // ==================== GAME STATE ====================
    let gameState = 'loading';
    let score = 0;
    let distance = 0;
    let level = 1;
    let health = 100;
    let speed = CONFIG.BASE_SPEED;
    let streak = 0;
    let maxStreak = 0;
    let multiplier = 1;
    let highScore = parseInt(localStorage.getItem('runner_highscore') || '0');

    // Player physics
    let playerLane = 0;
    let playerY = 0;
    let velocityY = 0;
    let jumpCount = 0;
    let isSliding = false;
    let slideTimer = 0;

    // Power-ups
    let powerups = { shield: 0, magnet: 0, double: 0 };

    // Screen shake
    let shakeAmount = 0;
    let shakeDecay = 0.9;

    // Objects
    let objects = [];
    let particles = [];
    let trails = [];

    // ==================== THREE.JS SETUP ====================
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000510);
    scene.fog = new THREE.FogExp2(0x000510, 0.008);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 10);
    camera.lookAt(0, 1, -20);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    document.getElementById('game').appendChild(renderer.domElement);

    // Lighting - brighter for visibility
    scene.add(new THREE.AmbientLight(0x6080c0, 0.8));

    const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
    mainLight.position.set(10, 30, 10);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.width = 2048;
    mainLight.shadow.mapSize.height = 2048;
    scene.add(mainLight);

    const rimLight = new THREE.DirectionalLight(0x00ffff, 0.5);
    rimLight.position.set(-10, 10, -10);
    scene.add(rimLight);

    // Front light for vehicle
    const frontLight = new THREE.DirectionalLight(0xffffff, 0.6);
    frontLight.position.set(0, 10, 20);
    scene.add(frontLight);

    // ==================== TRACK ====================
    function createTrack() {
        // Main road
        const roadGeo = new THREE.PlaneGeometry(18, 400);
        const roadMat = new THREE.MeshStandardMaterial({
            color: 0x030308,
            metalness: 0.2,
            roughness: 0.9
        });
        const road = new THREE.Mesh(roadGeo, roadMat);
        road.rotation.x = -Math.PI / 2;
        road.position.z = -150;
        road.receiveShadow = true;
        scene.add(road);

        // Grid lines
        const lineMat = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.1 });
        for (let z = -300; z <= 50; z += 5) {
            const geo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-9, 0.01, z),
                new THREE.Vector3(9, 0.01, z)
            ]);
            scene.add(new THREE.Line(geo, lineMat));
        }

        // Lane dividers
        const dividerMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3 });
        [-CONFIG.LANE_WIDTH, CONFIG.LANE_WIDTH].forEach(x => {
            for (let z = -300; z < 50; z += 8) {
                const divGeo = new THREE.PlaneGeometry(0.15, 4);
                const div = new THREE.Mesh(divGeo, dividerMat);
                div.rotation.x = -Math.PI / 2;
                div.position.set(x, 0.02, z);
                scene.add(div);
            }
        });

        // Side barriers with glow
        [-10, 10].forEach(x => {
            const barrierGeo = new THREE.BoxGeometry(0.5, 1, 400);
            const barrierMat = new THREE.MeshStandardMaterial({
                color: 0x001020,
                emissive: 0x001122,
                metalness: 0.9
            });
            const barrier = new THREE.Mesh(barrierGeo, barrierMat);
            barrier.position.set(x, 0.5, -150);
            scene.add(barrier);

            // Glow strip
            const glowGeo = new THREE.BoxGeometry(0.1, 0.1, 400);
            const glowMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            glow.position.set(x - Math.sign(x) * 0.25, 1, -150);
            scene.add(glow);
        });
    }
    createTrack();

    // ==================== PLAYER ====================
    const playerGroup = new THREE.Group();
    scene.add(playerGroup);

    let vehicleModel = null;
    const loader = new THREE.GLTFLoader();

    loader.load('roii.glb', (gltf) => {
        vehicleModel = gltf.scene;

        const box = new THREE.Box3().setFromObject(vehicleModel);
        const size = box.getSize(new THREE.Vector3());
        const scale = 5 / Math.max(size.x, size.y, size.z);
        vehicleModel.scale.set(scale, scale, scale);
        vehicleModel.rotation.y = Math.PI;
        // Raise vehicle above ground
        vehicleModel.position.y = size.y * scale * 0.5 + 0.3;

        vehicleModel.traverse((child) => {
            if (child.isMesh && child.material) {
                child.castShadow = true;
                child.material.transparent = true;
                child.material.opacity = 0.95;
                if (child.material.color) {
                    child.material.color.multiplyScalar(2.5);
                }
                child.material.emissive = new THREE.Color(0x666666);
                child.material.emissiveIntensity = 0.4;
            }
        });

        playerGroup.add(vehicleModel);
        createPlayerEffects();
        finishLoading();
    }, undefined, () => {
        createFallbackVehicle();
        finishLoading();
    });

    function createFallbackVehicle() {
        const bodyGeo = new THREE.BoxGeometry(2.5, 1, 4);
        const bodyMat = new THREE.MeshStandardMaterial({
            color: 0x00ffff,
            emissive: 0x004444,
            metalness: 0.8,
            roughness: 0.2
        });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.y = 0.7;
        body.castShadow = true;
        playerGroup.add(body);
        createPlayerEffects();
    }

    function createPlayerEffects() {
        // Engine glow
        const glowGeo = new THREE.BoxGeometry(0.4, 0.2, 0.1);
        const glowMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        [-0.6, 0.6].forEach(x => {
            const glow = new THREE.Mesh(glowGeo, glowMat);
            glow.position.set(x, 0.5, 2);
            playerGroup.add(glow);
        });

        // LiDAR ring on top
        const lidarGeo = new THREE.RingGeometry(0.2, 0.4, 16);
        const lidarMat = new THREE.MeshBasicMaterial({
            color: 0x9966ff, transparent: true, opacity: 0.8, side: THREE.DoubleSide
        });
        const lidar = new THREE.Mesh(lidarGeo, lidarMat);
        lidar.rotation.x = -Math.PI / 2;
        lidar.position.y = 2;
        playerGroup.add(lidar);
        playerGroup.userData.lidar = lidar;
    }

    function finishLoading() {
        document.getElementById('loading').classList.add('hidden');
        document.getElementById('highScoreDisplay').querySelector('span').textContent = highScore.toLocaleString();
        gameState = 'menu';
    }

    // ==================== GAME OBJECTS ====================
    function createDataPacket(x, z, type) {
        const group = new THREE.Group();
        const color = PACKET_COLORS[type];

        let coreGeo;
        if (type === 'lidar') coreGeo = new THREE.OctahedronGeometry(0.5);
        else if (type === 'camera') coreGeo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
        else coreGeo = new THREE.TetrahedronGeometry(0.5);

        const coreMat = new THREE.MeshStandardMaterial({
            color, emissive: color, emissiveIntensity: 2, metalness: 1, roughness: 0
        });
        group.add(new THREE.Mesh(coreGeo, coreMat));

        // Outer ring
        const ringGeo = new THREE.RingGeometry(0.6, 0.75, 16);
        const ringMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.rotation.x = Math.PI / 2;
        group.add(ring);

        // Light
        group.add(new THREE.PointLight(color, 0.5, 4));

        group.position.set(x, 1.5, z);
        scene.add(group);
        return { type: 'packet', packetType: type, mesh: group, x, z, y: 1.5, active: true };
    }

    function createObstacle(x, z, obstacleType = 'fault') {
        const group = new THREE.Group();

        if (obstacleType === 'fault') {
            // Tall obstacle - must jump
            const boxGeo = new THREE.BoxGeometry(1.5, 2.5, 1.5);
            const boxMat = new THREE.MeshStandardMaterial({
                color: 0xff0044, emissive: 0x330011, metalness: 0.5
            });
            const box = new THREE.Mesh(boxGeo, boxMat);
            box.position.y = 1.25;
            box.castShadow = true;
            group.add(box);

            // Wireframe
            const wireMat = new THREE.MeshBasicMaterial({ color: 0xff0044, wireframe: true, transparent: true, opacity: 0.5 });
            const wire = new THREE.Mesh(new THREE.BoxGeometry(1.7, 2.7, 1.7), wireMat);
            wire.position.y = 1.25;
            group.add(wire);

            group.add(new THREE.PointLight(0xff0044, 0.6, 5));
        } else if (obstacleType === 'low') {
            // Low obstacle - must slide
            const boxGeo = new THREE.BoxGeometry(2, 1, 1.5);
            const boxMat = new THREE.MeshStandardMaterial({
                color: 0xff6600, emissive: 0x331100, metalness: 0.5
            });
            const box = new THREE.Mesh(boxGeo, boxMat);
            box.position.y = 1.8;
            box.castShadow = true;
            group.add(box);

            group.add(new THREE.PointLight(0xff6600, 0.4, 4));
        } else {
            // Laser gate - must slide
            const poleGeo = new THREE.CylinderGeometry(0.1, 0.1, 3);
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            [-1, 1].forEach(side => {
                const pole = new THREE.Mesh(poleGeo, poleMat);
                pole.position.set(side * 1.2, 1.5, 0);
                group.add(pole);
            });

            // Laser beam
            const laserGeo = new THREE.BoxGeometry(2.4, 0.1, 0.1);
            const laserMat = new THREE.MeshBasicMaterial({ color: 0xff0066 });
            const laser = new THREE.Mesh(laserGeo, laserMat);
            laser.position.y = 2;
            group.add(laser);
            group.userData.laser = laser;

            group.add(new THREE.PointLight(0xff0066, 0.5, 4));
        }

        group.position.set(x, 0, z);
        scene.add(group);
        return { type: 'obstacle', obstacleType, mesh: group, x, z, active: true };
    }

    function createPowerup(x, z, powerType) {
        const group = new THREE.Group();
        const colors = { shield: 0x00ff00, magnet: 0xff00ff, double: 0xffff00 };
        const color = colors[powerType];

        // Sphere
        const sphereGeo = new THREE.SphereGeometry(0.5, 16, 16);
        const sphereMat = new THREE.MeshStandardMaterial({
            color, emissive: color, emissiveIntensity: 1, metalness: 0.9, roughness: 0.1
        });
        group.add(new THREE.Mesh(sphereGeo, sphereMat));

        // Outer ring
        const ringGeo = new THREE.TorusGeometry(0.7, 0.05, 8, 16);
        const ringMat = new THREE.MeshBasicMaterial({ color });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        group.add(ring);
        group.userData.ring = ring;

        group.add(new THREE.PointLight(color, 0.6, 5));

        group.position.set(x, 1.5, z);
        scene.add(group);
        return { type: 'powerup', powerType, mesh: group, x, z, y: 1.5, active: true };
    }

    // ==================== PARTICLES ====================
    function spawnParticles(x, y, z, color, count = 20) {
        for (let i = 0; i < count; i++) {
            const geo = new THREE.OctahedronGeometry(0.1);
            const mat = new THREE.MeshBasicMaterial({ color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            scene.add(mesh);
            particles.push({
                mesh,
                vx: (Math.random() - 0.5) * 10,
                vy: Math.random() * 8 + 3,
                vz: (Math.random() - 0.5) * 10,
                life: 1
            });
        }
    }

    function spawnTrail() {
        if (gameState !== 'playing') return;
        const geo = new THREE.BoxGeometry(0.3, 0.1, 0.3);
        const mat = new THREE.MeshBasicMaterial({
            color: 0x00ffff, transparent: true, opacity: 0.6
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.copy(playerGroup.position);
        mesh.position.y = 0.1;
        scene.add(mesh);
        trails.push({ mesh, life: 1 });
    }

    // ==================== SPAWNING ====================
    let spawnTimer = 0;
    let lastSpawnZ = -30;

    function spawnObjects(delta) {
        if (gameState !== 'playing') return;

        spawnTimer += delta;
        if (spawnTimer < 0.25) return;
        spawnTimer = 0;

        // Find furthest object
        let furthestZ = -30;
        objects.forEach(obj => { if (obj.z < furthestZ) furthestZ = obj.z; });

        if (furthestZ > -CONFIG.SPAWN_DISTANCE) {
            const spawnZ = furthestZ - (12 + Math.random() * 10);
            const rand = Math.random();

            if (rand < 0.45) {
                // Data packets
                const lane = Math.floor(Math.random() * CONFIG.LANE_COUNT) - 1;
                const type = PACKET_TYPES[Math.floor(Math.random() * PACKET_TYPES.length)];
                objects.push(createDataPacket(lane * CONFIG.LANE_WIDTH, spawnZ, type));

                // Sometimes spawn in multiple lanes
                if (Math.random() > 0.6) {
                    const otherLane = lane === 0 ? (Math.random() > 0.5 ? -1 : 1) : -lane;
                    const otherType = PACKET_TYPES[Math.floor(Math.random() * PACKET_TYPES.length)];
                    objects.push(createDataPacket(otherLane * CONFIG.LANE_WIDTH, spawnZ, otherType));
                }
            } else if (rand < 0.85) {
                // Obstacles
                const lane = Math.floor(Math.random() * CONFIG.LANE_COUNT) - 1;
                const obstacleTypes = ['fault', 'fault', 'low', 'laser'];
                const obstacleType = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                objects.push(createObstacle(lane * CONFIG.LANE_WIDTH, spawnZ, obstacleType));

                // Multi-lane obstacles at higher levels
                if (level >= 3 && Math.random() > 0.7) {
                    const otherLane = lane === 0 ? (Math.random() > 0.5 ? -1 : 1) : (lane === 1 ? 0 : 0);
                    objects.push(createObstacle(otherLane * CONFIG.LANE_WIDTH, spawnZ - 2, obstacleType));
                }
            } else {
                // Power-ups (rare)
                const lane = Math.floor(Math.random() * CONFIG.LANE_COUNT) - 1;
                const powerTypes = ['shield', 'magnet', 'double'];
                const powerType = powerTypes[Math.floor(Math.random() * powerTypes.length)];
                objects.push(createPowerup(lane * CONFIG.LANE_WIDTH, spawnZ, powerType));
            }
        }
    }

    // ==================== INPUT ====================
    let touchStartX = 0, touchStartY = 0;
    let inputBuffer = { left: false, right: false, jump: false, slide: false };

    function moveLeft() {
        if (playerLane > -1) {
            playerLane--;
            updateLaneIndicators();
        }
    }

    function moveRight() {
        if (playerLane < 1) {
            playerLane++;
            updateLaneIndicators();
        }
    }

    function jump() {
        if (jumpCount < 2 && !isSliding) {
            velocityY = jumpCount === 0 ? CONFIG.JUMP_FORCE : CONFIG.DOUBLE_JUMP_FORCE;
            jumpCount++;
            if (jumpCount === 1) audio.playJump();
            else audio.playDoubleJump();
        }
    }

    function slide() {
        if (!isSliding && jumpCount === 0) {
            isSliding = true;
            slideTimer = CONFIG.SLIDE_DURATION;
            audio.playSlide();
        }
    }

    document.addEventListener('keydown', (e) => {
        if (gameState !== 'playing') return;

        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') moveLeft();
        else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') moveRight();
        else if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W' || e.key === ' ') {
            e.preventDefault();
            jump();
        }
        else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') slide();
    });

    // Touch controls
    document.getElementById('touchLeft').addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (gameState === 'playing') moveLeft();
    });
    document.getElementById('touchRight').addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (gameState === 'playing') moveRight();
    });

    document.addEventListener('touchstart', (e) => {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
    });

    document.addEventListener('touchend', (e) => {
        if (gameState !== 'playing') return;
        const dx = e.changedTouches[0].clientX - touchStartX;
        const dy = e.changedTouches[0].clientY - touchStartY;

        if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > 30) {
            if (dy < 0) jump();
            else slide();
        }
    });

    // ==================== COLLISION ====================
    function checkCollisions() {
        const px = playerLane * CONFIG.LANE_WIDTH;
        const py = playerY;
        const playerHeight = isSliding ? 0.5 : 1.5;

        objects.forEach(obj => {
            if (!obj.active) return;

            let dx = Math.abs(obj.x - px);
            const dz = Math.abs(obj.z);

            // Magnet effect
            if (powerups.magnet > 0 && obj.type === 'packet') {
                if (dx < 6 && dz < 8) {
                    obj.x += (px - obj.x) * 0.1;
                    obj.mesh.position.x = obj.x;
                    dx = Math.abs(obj.x - px);
                }
            }

            if (dx < 1.5 && dz < 2) {
                if (obj.type === 'packet') {
                    collectPacket(obj);
                    obj.active = false;
                } else if (obj.type === 'powerup') {
                    collectPowerup(obj);
                    obj.active = false;
                } else if (obj.type === 'obstacle') {
                    // Check if avoided
                    const avoided = (
                        (obj.obstacleType === 'fault' && py > 1.5) ||
                        ((obj.obstacleType === 'low' || obj.obstacleType === 'laser') && isSliding)
                    );

                    if (!avoided) {
                        if (powerups.shield > 0) {
                            powerups.shield = 0;
                            updatePowerupUI();
                            spawnParticles(obj.x, 1.5, obj.z, 0x00ff00, 30);
                            obj.active = false;
                        } else {
                            takeDamage(25);
                            obj.active = false;
                        }
                    }
                }
            }
        });
    }

    function collectPacket(obj) {
        const value = PACKET_VALUES[obj.packetType];
        const bonusMultiplier = powerups.double > 0 ? 2 : 1;
        const points = Math.floor(value * multiplier * bonusMultiplier);

        score += points;
        streak++;
        maxStreak = Math.max(maxStreak, streak);
        multiplier = Math.min(1 + streak * 0.05, 5);

        audio.playCollect(obj.packetType);
        spawnParticles(obj.x, obj.y, obj.z, PACKET_COLORS[obj.packetType], 15);
        showCombo('+' + points, PACKET_COLORS[obj.packetType]);
        screenFlash('collect');

        // Combo sound at milestones
        if (streak % 10 === 0) audio.playCombo(Math.floor(streak / 10));

        // Small heal
        health = Math.min(100, health + 1);

        updateUI();
    }

    function collectPowerup(obj) {
        powerups[obj.powerType] = CONFIG.POWERUP_DURATION;
        audio.playPowerup();
        spawnParticles(obj.x, obj.y, obj.z, obj.mesh.children[0].material.color.getHex(), 25);
        showCombo(obj.powerType.toUpperCase() + '!', obj.mesh.children[0].material.color.getHex());
        screenFlash('powerup');
        updatePowerupUI();
    }

    function takeDamage(amount) {
        health -= amount;
        streak = 0;
        multiplier = 1;
        shakeAmount = 0.5;

        audio.playDamage();
        screenFlash('damage');
        showCombo('FAULT!', 0xff0044);

        if (health <= 0) {
            health = 0;
            gameOver();
        }
        updateUI();
    }

    // ==================== UI ====================
    function updateUI() {
        document.getElementById('score').textContent = score.toLocaleString();
        document.getElementById('distance').textContent = Math.floor(distance) + 'm';
        document.getElementById('level').textContent = level;
        document.getElementById('speed').textContent = (speed / 10).toFixed(1) + ' Gbps';
        document.getElementById('streakCount').textContent = streak;
        document.getElementById('multiplier').textContent = 'x' + multiplier.toFixed(1);

        // Health bar
        const healthFill = document.getElementById('healthFill');
        healthFill.style.width = health + '%';
        healthFill.className = 'health-fill' + (health < 25 ? ' danger' : health < 50 ? ' warning' : '');
        document.getElementById('healthPercent').textContent = Math.floor(health) + '%';
    }

    function updateLaneIndicators() {
        [-1, 0, 1].forEach(lane => {
            const el = document.getElementById('lane' + lane);
            el.classList.toggle('active', lane === playerLane);
        });
    }

    function updatePowerupUI() {
        ['shield', 'magnet', 'double'].forEach(type => {
            const el = document.getElementById('power' + type.charAt(0).toUpperCase() + type.slice(1));
            el.classList.toggle('active', powerups[type] > 0);
        });
    }

    function showCombo(text, color) {
        const el = document.getElementById('comboText');
        el.textContent = text;
        el.style.color = '#' + (typeof color === 'number' ? color.toString(16).padStart(6, '0') : color);
        el.classList.remove('show');
        void el.offsetWidth; // Trigger reflow
        el.classList.add('show');
    }

    function screenFlash(type) {
        const el = document.getElementById('screenFlash');
        el.className = 'screen-flash ' + type;
        setTimeout(() => el.className = 'screen-flash', 400);
    }

    // ==================== GAME FLOW ====================
    function startGame() {
        audio.init();
        audio.resume();

        gameState = 'playing';
        score = 0;
        distance = 0;
        level = 1;
        health = 100;
        speed = CONFIG.BASE_SPEED;
        streak = 0;
        maxStreak = 0;
        multiplier = 1;
        playerLane = 0;
        playerY = 0;
        velocityY = 0;
        jumpCount = 0;
        isSliding = false;
        powerups = { shield: 0, magnet: 0, double: 0 };

        // Clear objects
        objects.forEach(obj => scene.remove(obj.mesh));
        objects = [];
        particles.forEach(p => scene.remove(p.mesh));
        particles = [];
        trails.forEach(t => scene.remove(t.mesh));
        trails = [];

        playerGroup.position.set(0, 0, 0);
        playerGroup.rotation.set(0, 0, 0);
        playerGroup.scale.set(1, 1, 1);

        updateUI();
        updateLaneIndicators();
        updatePowerupUI();

        document.getElementById('menuScreen').classList.add('hidden');
        document.getElementById('gameOver').classList.add('hidden');
        document.getElementById('hud').classList.remove('hidden');
        document.getElementById('streakDisplay').classList.remove('hidden');
        document.getElementById('powerupBar').classList.remove('hidden');
        document.getElementById('laneIndicators').classList.remove('hidden');
        document.getElementById('healthContainer').classList.remove('hidden');
    }

    function gameOver() {
        gameState = 'gameover';
        audio.playGameOver();

        // Check high score
        const isNewHighScore = score > highScore;
        if (isNewHighScore) {
            highScore = score;
            localStorage.setItem('runner_highscore', highScore.toString());
        }

        document.getElementById('finalScore').textContent = score.toLocaleString();
        document.getElementById('finalDistance').textContent = Math.floor(distance) + 'm';
        document.getElementById('finalStreak').textContent = maxStreak;
        document.getElementById('finalLevel').textContent = level;
        document.getElementById('newHighScore').classList.toggle('hidden', !isNewHighScore);

        hideHUD();
        document.getElementById('gameOver').classList.remove('hidden');
    }

    function showMenu() {
        gameState = 'menu';
        document.getElementById('gameOver').classList.add('hidden');
        document.getElementById('menuScreen').classList.remove('hidden');
        document.getElementById('highScoreDisplay').querySelector('span').textContent = highScore.toLocaleString();
        hideHUD();
    }

    function hideHUD() {
        document.getElementById('hud').classList.add('hidden');
        document.getElementById('streakDisplay').classList.add('hidden');
        document.getElementById('powerupBar').classList.add('hidden');
        document.getElementById('laneIndicators').classList.add('hidden');
        document.getElementById('healthContainer').classList.add('hidden');
    }

    // ==================== SOUND TOGGLE ====================
    document.getElementById('soundToggle').addEventListener('click', () => {
        audio.init();
        const enabled = audio.toggle();
        document.getElementById('soundToggle').textContent = enabled ? 'üîä' : 'üîá';
        document.getElementById('soundToggle').classList.toggle('muted', !enabled);
    });

    // ==================== GAME LOOP ====================
    let lastTime = 0;
    let trailTimer = 0;

    function animate(time) {
        requestAnimationFrame(animate);

        const delta = Math.min((time - lastTime) / 1000, 0.05);
        lastTime = time;

        if (gameState === 'playing') {
            // Speed increases over time
            speed = Math.min(CONFIG.MAX_SPEED, CONFIG.BASE_SPEED + distance * 0.01 + (level - 1) * 5);
            distance += speed * delta;

            // Level up
            if (level < CONFIG.LEVEL_DISTANCE.length && distance >= CONFIG.LEVEL_DISTANCE[level - 1]) {
                level++;
                audio.playLevelUp();
                showCombo('LEVEL ' + level, 0x00ff00);
                screenFlash('powerup');
            }

            // Player horizontal movement
            const targetX = playerLane * CONFIG.LANE_WIDTH;
            playerGroup.position.x += (targetX - playerGroup.position.x) * delta * 15;

            // Jump physics
            if (jumpCount > 0 || playerY > 0) {
                playerY += velocityY * delta;
                velocityY -= CONFIG.GRAVITY * delta;

                if (playerY <= 0) {
                    playerY = 0;
                    jumpCount = 0;
                    velocityY = 0;
                }
            }

            // Slide timer
            if (isSliding) {
                slideTimer -= delta;
                if (slideTimer <= 0) {
                    isSliding = false;
                }
            }

            // Apply player transform
            playerGroup.position.y = playerY;
            playerGroup.scale.y = isSliding ? 0.5 : 1;
            playerGroup.rotation.z = (targetX - playerGroup.position.x) * -0.1;
            playerGroup.rotation.x = jumpCount > 0 ? -0.1 : (isSliding ? 0.1 : 0);

            // Screen shake
            if (shakeAmount > 0.01) {
                camera.position.x = (Math.random() - 0.5) * shakeAmount;
                camera.position.y = 5 + (Math.random() - 0.5) * shakeAmount;
                shakeAmount *= shakeDecay;
            } else {
                camera.position.x = 0;
                camera.position.y = 5;
            }

            // Power-up timers
            Object.keys(powerups).forEach(key => {
                if (powerups[key] > 0) {
                    powerups[key] -= delta;
                    if (powerups[key] <= 0) powerups[key] = 0;
                }
            });
            updatePowerupUI();

            // Move objects
            objects.forEach(obj => {
                obj.z += speed * delta;
                obj.mesh.position.z = obj.z;

                if (obj.type === 'packet' || obj.type === 'powerup') {
                    obj.mesh.rotation.y += delta * 3;
                    obj.mesh.position.y = obj.y + Math.sin(time * 0.005) * 0.2;
                    if (obj.mesh.userData.ring) {
                        obj.mesh.userData.ring.rotation.x += delta * 2;
                        obj.mesh.userData.ring.rotation.y += delta;
                    }
                }
                if (obj.type === 'obstacle' && obj.mesh.userData.laser) {
                    obj.mesh.userData.laser.material.opacity = 0.5 + Math.sin(time * 0.02) * 0.5;
                }
            });

            // Remove off-screen objects
            objects = objects.filter(obj => {
                if (obj.z > 15 || !obj.active) {
                    scene.remove(obj.mesh);
                    return false;
                }
                return true;
            });

            spawnObjects(delta);
            checkCollisions();

            // LiDAR pulse effect
            if (playerGroup.userData && playerGroup.userData.lidar) {
                const s = 1 + Math.sin(time * 0.008) * 0.3;
                playerGroup.userData.lidar.scale.set(s, s, s);
            }

            // Trail effect
            trailTimer += delta;
            if (trailTimer > 0.05) {
                trailTimer = 0;
                spawnTrail();
            }

            updateUI();
        }

        // Update particles
        particles = particles.filter(p => {
            p.life -= delta * 2;
            if (p.life <= 0) {
                scene.remove(p.mesh);
                return false;
            }
            p.mesh.position.x += p.vx * delta;
            p.mesh.position.y += p.vy * delta;
            p.mesh.position.z += p.vz * delta;
            p.vy -= 20 * delta;
            p.mesh.scale.setScalar(p.life);
            return true;
        });

        // Update trails
        trails = trails.filter(t => {
            t.life -= delta * 3;
            if (t.life <= 0) {
                scene.remove(t.mesh);
                return false;
            }
            t.mesh.material.opacity = t.life * 0.6;
            t.mesh.scale.setScalar(t.life);
            return true;
        });

        renderer.render(scene, camera);
    }

    // ==================== RESIZE ====================
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate(0);
    </script>
</body>
</html>
